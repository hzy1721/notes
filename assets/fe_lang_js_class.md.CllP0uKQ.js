import{_ as s}from"./chunks/class-extends.BOmew0s1.js";import{_ as i,c as a,o as l,a1 as n}from"./chunks/framework.mNpZ2GHZ.js";const u=JSON.parse('{"title":"class","description":"","frontmatter":{},"headers":[],"relativePath":"fe/lang/js/class.md","filePath":"fe/lang/js/class.md","lastUpdated":1702822707000}'),e={name:"fe/lang/js/class.md"},t=n(`<h1 id="class" tabindex="-1">class <a class="header-anchor" href="#class" aria-label="Permalink to &quot;class&quot;">​</a></h1><p>ES6 引入的创建自定义类型的方式。</p><ul><li>可以代替原来的构造函数</li><li>更符合 OOP 的书写习惯</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SuperClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 属性</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  prop1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value1;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 构造方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 访问器属性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  get</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> prop2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  set</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> prop2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 实例方法</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  method1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 静态属性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  static</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> staticProp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 静态方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> staticMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myInstance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h2><ul><li>创建一个名为 <code>MyClass</code> 的构造函数，参数和函数体来自 <code>constructor</code></li><li>在函数体内把属性设置到 <code>this</code> 上，比如 <code>prop1</code></li><li>把访问器属性和实例方法设置在原型对象 <code>MyClass.prototype</code> 上，比如 <code>prop2</code>、<code>method1</code></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// function</span></span></code></pre></div><h2 id="与构造函数的区别" tabindex="-1">与构造函数的区别 <a class="header-anchor" href="#与构造函数的区别" aria-label="Permalink to &quot;与构造函数的区别&quot;">​</a></h2><ul><li>内部属性 <code>[[IsClassConstructor]]</code> 的值为 <code>true</code><ul><li>JS 会在很多地方用到这个属性，来区分 <code>class</code> 和构造函数 <ul><li>必须使用 <code>new</code> 调用，直接调用会报错</li><li><code>toString()</code> 的输出以 <code>class</code> 开头，而不是 <code>function</code></li></ul></li></ul></li><li>位于原型上的方法不可枚举 <ul><li><code>enumerable: false</code></li></ul></li><li>总是处于严格模式</li></ul><h2 id="箭头函数属性" tabindex="-1">箭头函数属性 <a class="header-anchor" href="#箭头函数属性" aria-label="Permalink to &quot;箭头函数属性&quot;">​</a></h2><p>由于箭头函数的 <code>this</code> 会绑定为外层的 <code>this</code>，使用箭头函数属性代替函数声明可以将函数的 <code>this</code> 绑定为创建的对象本身，无论函数被传递到什么地方调用。</p><p>箭头函数属性会作为自有属性在每个对象上都有一份拷贝。</p><h2 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h2><p>使用 <code>extends</code> 声明继承，只支持单继承。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rabbit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre></div><p>原理：</p><ul><li>把 <code>Rabbit.prototype.[[Prototype]]</code> 设置为 <code>Animal.prototype</code></li><li>把 <code>Rabbit.[[Prototype]]</code> 设置为 <code>Animal</code></li></ul><img src="`+s+`" width="70%"><ul><li><strong>必须</strong>在子类 constructor 中使用 <code>super()</code> 调用父类 constructor <ul><li>在 <code>this</code> 的访问之前</li><li>为了实现父类实例属性的继承 (非原型属性)</li><li>使用 <code>new</code> 执行子类 constructor 时，不会创建空对象并赋值给 <code>this</code>，而是期望父类 constructor 完成这项工作</li></ul></li><li>可以在子类方法中使用 <code>super.method()</code> 调用父类方法</li><li><code>super</code> 使用内部属性 <code>[[HomeObject]]</code> 实现，值为函数声明时所在的对象</li><li>箭头函数没有自己的 <code>super</code>，与声明时外部环境的 <code>super</code> 相同</li></ul><p>默认生成的 constructor：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rabbit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,21),p=[t];function h(k,d,c,o,r,g){return l(),a("div",null,p)}const F=i(e,[["render",h]]);export{u as __pageData,F as default};
