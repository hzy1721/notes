import{_ as e,c as o,o as d,d as l}from"./app.e6616afd.js";const h=JSON.parse('{"title":"Set","description":"","frontmatter":{},"headers":[{"level":3,"title":"WeakSet","slug":"weakset","link":"#weakset","children":[]}],"relativePath":"fe/js/set.md"}'),c={name:"fe/js/set.md"},t=l('<h1 id="set" tabindex="-1">Set <a class="header-anchor" href="#set" aria-hidden="true">#</a></h1><p><code>Set</code> 表示唯一元素的集合，重复添加相同元素只会保留一个，ES6 引入。</p><p>API：</p><ul><li><code>new Set(iterable)</code>：基于可迭代对象创建集合</li><li><code>set.add(value)</code>：添加元素，返回 set 本身</li><li><code>set.delete(value)</code>：删除元素，元素存在返回 <code>true</code>，不存在返回 <code>false</code></li><li><code>set.has(value)</code>：元素是否存在</li><li><code>set.clear()</code>：清空集合</li><li><code>set.size</code>：元素个数</li></ul><p>遍历 Set：</p><ul><li><code>set.forEach((value, valueAgain, set) =&gt; { ... })</code><ul><li><code>valueAgain</code> 与 <code>value</code> 相同，为了与 <code>Map</code> 兼容</li></ul></li><li><code>set.keys()</code><ul><li>返回所有值的可迭代对象，<code>for...of</code> 默认使用</li></ul></li><li><code>set.values()</code><ul><li>与 <code>set.keys()</code> 相同，为了兼容 <code>Map</code></li></ul></li><li><code>set.entries()</code><ul><li>返回 <code>[value, valueAgain]</code> 的可迭代对象</li></ul></li></ul><h3 id="weakset" tabindex="-1">WeakSet <a class="header-anchor" href="#weakset" aria-hidden="true">#</a></h3><p><code>WeakSet</code> 与 <code>Set</code> 有两个区别：</p><ul><li>元素只能是对象，不能是其他类型</li><li>元素都是弱引用，垃圾回收不考虑 WeakSet 对元素的引用</li></ul><p><code>WeakSet</code> 适合临时存放对象或者与对象相关联的信息，对象一旦不被使用，<code>WeakSet</code> 里的相关信息就会自动消失。</p><p>由于 <code>WeakSet</code> 里的元素随时有可能因为垃圾回收而消失，因此规定 <code>WeakSet</code> <strong>不可遍历</strong>。</p><p>API：</p><ul><li><code>new WeakSet(iterable)</code></li><li><code>weakSet.add(value)</code></li><li><code>weakSet.delete(value)</code></li><li><code>weakSet.has(value)</code></li><li><strong>没有</strong> <code>clear()</code> 和 <code>size</code></li></ul>',13),a=[t];function i(s,r,u,n,p,_){return d(),o("div",null,a)}const k=e(c,[["render",i]]);export{h as __pageData,k as default};
