import{_ as e,c as t,o as i,a1 as o}from"./chunks/framework.mNpZ2GHZ.js";const h=JSON.parse('{"title":"PC 客户端","description":"","frontmatter":{},"headers":[],"relativePath":"fe/desktop/index.md","filePath":"fe/desktop/index.md","lastUpdated":1720354129000}'),a={name:"fe/desktop/index.md"},l=o('<h1 id="pc-客户端" tabindex="-1">PC 客户端 <a class="header-anchor" href="#pc-客户端" aria-label="Permalink to &quot;PC 客户端&quot;">​</a></h1><p>前端的跨端方案可以分为浏览器和原生 2 部分：</p><ul><li>浏览器：用于渲染页面、执行脚本，内置浏览器或调用系统浏览器 <ul><li>内置浏览器：不需要考虑兼容性，可以使用较新的版本和特性</li><li>系统浏览器：包体积小</li></ul></li><li>原生：系统 API 的 JS 绑定，如果用 Node 就不需要绑定 <ul><li>Node：学习成本低</li><li>Rust：安全性高</li></ul></li></ul><p>Electron 封装了 Chromium 和 Node，分别提供页面渲染能力和原生能力，是使用前端技术栈开发 PC 客户端的主流框架。但是也存在包体积大、CPU 占用高、Chromium 安全漏洞的问题。</p><p>Tauri 不封装 Chromium，而是调用系统 WebView，大幅减小了包体积，缺点是不自带 WebView 的系统需要用户额外安装。原生能力基于 Rust 库提供 JS 绑定，没有使用 Node。</p><p>目前 Tauri 的生态和文档不如 Electron 成熟，是否能应对大部分业务需求存在疑问，可行性和稳定性还需开源社区进一步验证。</p><p>NW.js 是比 Electron 更早的解决方案，遵循类似的技术架构，使用人数较少，更推荐用主流的 Electron。</p>',7),r=[l];function s(d,n,c,p,_,u){return i(),t("div",null,r)}const f=e(a,[["render",s]]);export{h as __pageData,f as default};
