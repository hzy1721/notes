import{_ as i,c as l,o as e,a as t}from"./app.e3dff596.js";const o="/assets/vitals.d2fcefc5.png",s="/assets/lcp-demo-1.cfa09495.avif",a="/assets/lcp-demo-2.3595a1ae.avif",c="/assets/lcp-demo-3.e6163528.avif",d="/assets/fid-demo-1.8464335d.svg",r="/assets/session-window.d5700f86.webm",n="/assets/cls-demo.ee3690b9.avif",P=JSON.parse('{"title":"Web 性能指标","description":"","frontmatter":{},"headers":[{"level":2,"title":"LCP","slug":"lcp","link":"#lcp","children":[]},{"level":2,"title":"FID","slug":"fid","link":"#fid","children":[]},{"level":2,"title":"CLS","slug":"cls","link":"#cls","children":[]},{"level":2,"title":"测量工具","slug":"测量工具","link":"#测量工具","children":[]}],"relativePath":"fe/design/web-vitals.md"}'),p={name:"fe/design/web-vitals.md"},h=t('<h1 id="web-性能指标" tabindex="-1">Web 性能指标 <a class="header-anchor" href="#web-性能指标" aria-hidden="true">#</a></h1><ul><li>LCP (Largest Contentful Paint) <ul><li>最大内容绘制</li><li>测量加载性能 (Loading)</li><li>应该小于 2.5 s</li></ul></li><li>FID (First Input Delay) <ul><li>首次输入延迟</li><li>测量交互性 (Interactivity)</li><li>应该小于 100 ms</li></ul></li><li>CLS (Cumulative Layout Shift) <ul><li>累积布局偏移</li><li>测量视觉稳定性 (Visual Stability)</li><li>应该小于 0.1</li></ul></li></ul><p><img src="'+o+'" alt=""></p><h2 id="lcp" tabindex="-1">LCP <a class="header-anchor" href="#lcp" aria-hidden="true">#</a></h2><p>页面可视区域内最大元素完成渲染的时间，相对于页面首次开始加载的时间。</p><p>考虑的元素类型：</p><ul><li><code>&lt;img&gt;</code> 元素</li><li>内嵌在 <code>&lt;svg&gt;</code> 元素中的 <code>&lt;image&gt;</code> 元素</li><li><code>&lt;video&gt;</code> 元素</li><li>通过 <code>url()</code> 函数加载背景图片的元素</li><li>包含文本节点或行级文本元素的块级元素</li></ul><p>确定元素的大小：</p><ul><li>只考虑可见区域，不考虑溢出部分</li><li>对于图片，考虑原始尺寸和可见尺寸的较小值</li><li>对于文本，只考虑文本节点的大小 (包含所有文本节点的最小矩形)</li><li>不考虑 margin、border、padding</li></ul><p>计算过程：</p><ul><li>浏览器绘制第一帧后立即分发一个 LCP 类型的 <code>PerformanceEntry</code></li><li>渲染后续帧时，如果有新的<strong>可见</strong>元素比最大元素更大，分发一个新的 <code>PerformanceEntry</code><ul><li>只会考虑可见元素初次渲染时的大小，后续的尺寸和位置改变不会被考虑</li><li>如果元素在屏幕外完成渲染，后续变为可见，不会被考虑</li></ul></li><li>如果最大元素被移除，仍保持这个元素为最大元素</li><li>当用户开始交互时 (点击、滚动、触摸)，浏览器停止分发 <code>PerformanceEntry</code></li><li>最新的一条 <code>PerformanceEntry</code> 代表了绘制的最大内容</li></ul><p><img src="'+s+'" alt=""><img src="'+a+'" alt=""><img src="'+c+'" alt=""></p><h2 id="fid" tabindex="-1">FID <a class="header-anchor" href="#fid" aria-hidden="true">#</a></h2><p>从用户第一次与页面交互到浏览器做出响应、开始执行处理程序所需的时间。</p><ul><li>只考虑不连续操作 (点击、触摸)，不考虑连续操作 (滚动、缩放)</li><li>测量从接收到事件到主线程下一次空闲的时间差值，没有处理程序也可以计算 FID</li><li>输入延迟主要是由页面加载过程中长任务的阻塞造成的</li></ul><p><img src="'+d+'" alt=""></p><h2 id="cls" tabindex="-1">CLS <a class="header-anchor" href="#cls" aria-hidden="true">#</a></h2><p>会话窗口内所有意外布局偏移的最大累计分数。</p><p>会话窗口 (session window)：连续发生的一连串布局偏移，每次偏移的间隔时间小于 1 秒，窗口的最大时长为 5 秒。</p><p><video src="'+r+'" muted controls width="70%"></video></p><p>布局偏移 (layout shift)：可见元素的起始位置在相邻两帧之间发生了变更。</p><ul><li>不考虑新元素添加到 DOM 或已有元素的大小发生改变</li><li>如果某个元素的大小改变造成其他元素的起始位置变更，视为其他元素的布局偏移</li><li>浏览器会分发 <code>layout-shift</code> 类型的 <code>PerformanceEntry</code></li></ul><p>不稳定元素：发生布局偏移的元素。</p><p>布局偏移分数 = 影响分数 (impact fraction) * 距离分数 (distance fraction)</p><p>影响分数：相邻两帧<strong>所有</strong>不稳定元素的可见区域集合占总可见区域的比例。</p><p>距离分数：不稳定元素在相邻两帧中位移的<strong>最大</strong>距离占可见区域较大尺寸维度的比例 (宽度或高度，以较大者为准)。</p><img src="'+n+'" width="70%"><p>预期布局偏移：对用户交互进行响应的布局偏移通常没有问题，在用户进行不连续输入 500 ms 内的布局偏移会带有 <code>hadRecentInput</code> 标记，CLS 的计算会排除这些偏移。</p><ul><li>CSS 的 <code>transform</code> 不改变元素的起始位置，不会触发布局偏移 <ul><li>用 <code>scale()</code> 代替对 <code>width</code> 和 <code>height</code> 的修改</li><li>用 <code>translate()</code> 代替对 <code>top/bottom/left/right</code> 的修改</li></ul></li></ul><p>意外布局偏移：不属于预期布局偏移即为意外布局偏移。</p><h2 id="测量工具" tabindex="-1">测量工具 <a class="header-anchor" href="#测量工具" aria-hidden="true">#</a></h2><ul><li>web-vitals 库</li><li>Chrome DevTools Lighthouse</li></ul>',32),u=[h];function m(_,f,g,v,b,w){return e(),l("div",null,u)}const S=i(p,[["render",m]]);export{P as __pageData,S as default};
