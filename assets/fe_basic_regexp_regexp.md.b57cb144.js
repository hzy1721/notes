import{_ as e,c as d,o as t,d as o}from"./app.f24a99d1.js";const b=JSON.parse('{"title":"正则表达式","description":"","frontmatter":{},"headers":[{"level":2,"title":"字符类","slug":"字符类","link":"#字符类","children":[]},{"level":2,"title":"Unicode","slug":"unicode","link":"#unicode","children":[]},{"level":2,"title":"anchor","slug":"anchor","link":"#anchor","children":[]},{"level":2,"title":"词边界","slug":"词边界","link":"#词边界","children":[]},{"level":2,"title":"转义","slug":"转义","link":"#转义","children":[]},{"level":2,"title":"集合和范围","slug":"集合和范围","link":"#集合和范围","children":[]},{"level":2,"title":"量词","slug":"量词","link":"#量词","children":[]},{"level":2,"title":"greedy 和 lazy","slug":"greedy-和-lazy","link":"#greedy-和-lazy","children":[]},{"level":2,"title":"组","slug":"组","link":"#组","children":[]},{"level":2,"title":"或","slug":"或","link":"#或","children":[]},{"level":2,"title":"lookahead/behind","slug":"lookahead-behind","link":"#lookahead-behind","children":[]}],"relativePath":"fe/basic/regexp/regexp.md","lastUpdated":1681310459000}'),c={name:"fe/basic/regexp/regexp.md"},a=o('<h1 id="正则表达式" tabindex="-1">正则表达式 <a class="header-anchor" href="#正则表达式" aria-hidden="true">#</a></h1><p>正则表达式 (Regular Expression) 由 2 部分组成：</p><ul><li>模式 (pattern)</li><li>修饰符 (flag)</li></ul><table><thead><tr><th>修饰符</th><th>含义</th></tr></thead><tbody><tr><td><code>i</code></td><td>不区分大小写</td></tr><tr><td><code>g</code></td><td>搜索所有匹配项</td></tr><tr><td><code>m</code></td><td>多行模式</td></tr><tr><td><code>s</code></td><td>允许 <code>.</code> 匹配 <code>\\n</code></td></tr><tr><td><code>u</code></td><td>完整 Unicode 支持</td></tr><tr><td><code>y</code></td><td>在指定位置搜索</td></tr></tbody></table><p>创建正则表达式：</p><ul><li><code>new RegExp(&#39;pattern&#39;, &#39;flags&#39;)</code><ul><li>支持动态</li></ul></li><li><code>/pattern/flags</code><ul><li>静态</li></ul></li></ul><h2 id="字符类" tabindex="-1">字符类 <a class="header-anchor" href="#字符类" aria-hidden="true">#</a></h2><table><thead><tr><th>字符类</th><th>含义</th></tr></thead><tbody><tr><td><code>\\d</code> (digit)</td><td>数字</td></tr><tr><td><code>\\s</code> (space)</td><td>空白符：空格、<code>\\t</code>、<code>\\n</code>、<code>\\v</code>、<code>\\f</code>、<code>\\r</code> 等</td></tr><tr><td><code>\\w</code> (word)</td><td>“单字”：字母、数字、下划线 <code>_</code></td></tr><tr><td><code>\\D</code></td><td><code>\\d</code> 反向类，非数字</td></tr><tr><td><code>\\S</code></td><td><code>\\S</code> 反向类，非空白符</td></tr><tr><td><code>\\W</code></td><td><code>\\w</code> 反向类，非字母、数字、下划线</td></tr><tr><td><code>.</code></td><td>除 <code>\\n</code> 外任何字符</td></tr></tbody></table><h2 id="unicode" tabindex="-1">Unicode <a class="header-anchor" href="#unicode" aria-hidden="true">#</a></h2><p><code>\\p{}</code> 和修饰符 <code>u</code> 可以匹配 Unicode 字符。</p><table><thead><tr><th>正则</th><th>全称</th><th>含义</th></tr></thead><tbody><tr><td><code>L</code></td><td>Letter</td><td>字母</td></tr><tr><td><code>Ll</code></td><td>lowercase</td><td>小写</td></tr><tr><td><code>Lm</code></td><td>modifier</td><td>修饰</td></tr><tr><td><code>Lt</code></td><td>titlecase</td><td>首字母大写</td></tr><tr><td><code>Lu</code></td><td>uppercase</td><td>大写</td></tr><tr><td><code>Lo</code></td><td>other</td><td>其他</td></tr></tbody></table><h2 id="anchor" tabindex="-1">anchor <a class="header-anchor" href="#anchor" aria-hidden="true">#</a></h2><p><code>^</code> 匹配开头，<code>$</code> 匹配结尾。使用修饰符 <code>m</code> 后也匹配每一行的开头和结尾。</p><h2 id="词边界" tabindex="-1">词边界 <a class="header-anchor" href="#词边界" aria-hidden="true">#</a></h2><p><code>\\b</code> 匹配词的边界，一侧匹配 <code>\\w</code>，一侧不匹配 <code>\\w</code>。</p><h2 id="转义" tabindex="-1">转义 <a class="header-anchor" href="#转义" aria-hidden="true">#</a></h2><p>特殊字符 <code>[ ] { } ( ) \\ ^ $ . | ? * +</code> 使用反斜杠 <code>\\</code> 进行转义。</p><p>正则字面量需要转义 <code>/</code>，普通字符串需要转义 <code>\\</code>。</p><h2 id="集合和范围" tabindex="-1">集合和范围 <a class="header-anchor" href="#集合和范围" aria-hidden="true">#</a></h2><p>集合 <code>[xxx]</code> 表示方括号中字符中的任意一个。</p><p>集合中可以包含范围，比如 <code>[a-z]</code>、<code>[A-Z]</code>、<code>[0-9]</code>。</p><p>在集合开头加上 <code>^</code> 表示除了方括号中字符之外的任意一个字符。</p><p>除了集合中有特殊含义的字符，其他特殊字符都不需要转义。</p><h2 id="量词" tabindex="-1">量词 <a class="header-anchor" href="#量词" aria-hidden="true">#</a></h2><p>量词表示匹配的字符数量。</p><ul><li>确切数量：<code>{n}</code></li><li>数量范围：<code>{lo, hi}</code> 闭区间，<code>hi</code> 省略表示无限</li><li>缩写： <ul><li><code>?</code>：<code>{0,1}</code></li><li><code>*</code>：<code>{0,}</code></li><li><code>+</code>：<code>{1,}</code></li></ul></li></ul><h2 id="greedy-和-lazy" tabindex="-1">greedy 和 lazy <a class="header-anchor" href="#greedy-和-lazy" aria-hidden="true">#</a></h2><p>量词匹配默认是贪婪的 (greedy)，尽可能多地匹配字符，直到不满足条件再回溯。</p><p>在量词后添加问号 <code>?</code> 启用惰性量词 (lazy)，比如 <code>??</code>、<code>*?</code>、<code>+?</code>，尽可能少地匹配字符，每次匹配成功后就停下来尝试匹配剩余正则部分。</p><h2 id="组" tabindex="-1">组 <a class="header-anchor" href="#组" aria-hidden="true">#</a></h2><p>用圆括号 <code>()</code> 括起来的部分称为捕获组 (capturing group)。</p><p>没有 <code>g</code> 修饰符的匹配结果数组会包含每个组的匹配结果，按照从左到右、从外到内的顺序编号。</p><p>在左括号后紧跟 <code>?&lt;name&gt;</code> 为组命名，通过 <code>res.groups.name</code> 访问。</p><p>如果必须使用组但不希望单独出现匹配结果，可以在开头添加 <code>?:</code>。</p><p>在正则中使用 <code>\\N</code> 和 <code>\\k&lt;name&gt;</code> 引用前面出现的组。</p><h2 id="或" tabindex="-1">或 <a class="header-anchor" href="#或" aria-hidden="true">#</a></h2><p>使用 <code>|</code> 表示或。</p><h2 id="lookahead-behind" tabindex="-1">lookahead/behind <a class="header-anchor" href="#lookahead-behind" aria-hidden="true">#</a></h2><p>lookahead (向前/右看)：</p><ul><li><code>X(?=Y)</code>：仅在后面是 <code>Y</code> 时匹配 <code>X</code></li><li><code>X(?!Y)</code>：仅在后面不是 <code>Y</code> 时匹配 <code>X</code></li></ul><p>lookbehind (向后/左看)：</p><ul><li><code>(?&lt;=Y)X</code>：仅在前面是 <code>Y</code> 时匹配 <code>X</code></li><li><code>(?&lt;!Y)X</code>：仅在前面不是 <code>Y</code> 时匹配 <code>X</code></li></ul>',42),l=[a];function r(i,h,n,p,s,u){return t(),d("div",null,l)}const _=e(c,[["render",r]]);export{b as __pageData,_ as default};
