import{_ as n,c as s,o as l,d as t}from"./app.a7b44f76.js";const a="/assets/timsort-merge.73033d04.png",m=JSON.parse('{"title":"Timsort","description":"","frontmatter":{},"headers":[{"level":2,"title":"run","slug":"run","link":"#run","children":[]},{"level":2,"title":"minrun","slug":"minrun","link":"#minrun","children":[]},{"level":2,"title":"扩充","slug":"扩充","link":"#扩充","children":[]},{"level":2,"title":"合并","slug":"合并","link":"#合并","children":[]}],"relativePath":"fe/js/timsort.md"}'),o={name:"fe/js/timsort.md"},r=t(`<h1 id="timsort" tabindex="-1">Timsort <a class="header-anchor" href="#timsort" aria-hidden="true">#</a></h1><p>ES2019 后标准规定 <code>Array.prototype.sort</code> 必须是稳定的，具体使用的排序算法取决于实现。</p><p>V8 使用 <strong>Timsort</strong> 对元素进行排序，Timsort 是一种归并排序的变体。</p><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最坏时间</th><th>最好时间</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(nlogn)</td><td>O(logn)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>Timsort</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>O(n)</td><td>稳定</td></tr></tbody></table><p>选择 Timsort 有以下原因：</p><ul><li>优秀的时间复杂度：最坏 O(nlogn)、最好 O(n)</li><li>具有稳定性，能满足标准的要求</li></ul><h2 id="run" tabindex="-1">run <a class="header-anchor" href="#run" aria-hidden="true">#</a></h2><p>Timsort 中的 run 表示一段有序的序列：</p><ul><li>升序：a[i-1] &lt;= a[i] &lt;= a[i+1]</li><li>严格降序：a[i-1] &gt; a[i] &gt; a[i+1]</li></ul><p>严格降序序列可以通过简单的翻转得到升序序列。</p><p>此处要求严格降序而不是降序是因为：</p><ul><li>降序序列翻转后可能会破坏稳定性</li><li>严格降序可以保证所有元素都不相同</li></ul><p>原始数组可能已经包含若干个 run，Timsort 称之为 natural run。</p><h2 id="minrun" tabindex="-1">minrun <a class="header-anchor" href="#minrun" aria-hidden="true">#</a></h2><p>Timsort 定义了 run 的最小长度 minrun，如果 natural run 的长度小于 minrun，则使用插入排序补充到 minrun 的长度。</p><p>如果数组长度为 n，则总共会生成 floor(n/minrun) 个初始 run。</p><p>minrun 的选取基于以下原则：</p><ul><li>如果 floor(n/minrun) 是 2 的幂或者稍小一些，归并过程将在两个长度接近的 run 之间发生，会比较高效</li><li>如果 floor(n/minrun) 比 2 的幂稍大一些，最后将是一个超长 run 和一个超短 run 进行合并，额外开销会很大</li></ul><p>所以需要选取 minrun 使 floor(n/minrun) 是 2 的幂或稍小一些。</p><p>Tim 测试了 8/16/32/64/128/256 这几个 2 的幂作为 minrun 的值，发现：</p><ul><li>如果选取 8，函数调用次数会非常多</li><li>如果选取 256，插入排序的元素移动次数会非常多</li><li>最终选择了 [32, 64] 作为 minrun 的范围，正中间的范围</li></ul><p>minrun 的具体计算方法如下：</p><ul><li>如果 n &lt; 64，则 minrun = n <ul><li>小数组全部使用插入排序</li></ul></li><li>否则在 [32, 64] 范围内选取 minrun，使 floor(n/minrun) 是 2 的幂或稍小一些</li></ul><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">compute_minrun</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">n</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#89DDFF;">):</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">n</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">r</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">n</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&gt;=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">64</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">r</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">|=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">n</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">n</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&gt;&gt;=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">n</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">r</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="扩充" tabindex="-1">扩充 <a class="header-anchor" href="#扩充" aria-hidden="true">#</a></h2><p>从左向右扫描，找到尽可能长的 natural run (长度不超过 minrun)：</p><ul><li>如果等于 minrun，则直接作为一个 run</li><li>否则使用插入排序把后面的元素插入到前面的 natural run 中，补充至 minrun 的长度</li></ul><h2 id="合并" tabindex="-1">合并 <a class="header-anchor" href="#合并" aria-hidden="true">#</a></h2><p>每生成一个 run 就尝试进行合并，使最右边的三个 run 满足以下条件 (记为 A/B/C)：</p><ul><li>A &gt; B + C</li><li>B &gt; C</li></ul><p>这样是为了让从右到左的 run 长度大致呈指数级递增，便于后续高效合并。</p><ul><li>如果 A &lt;= B + C，则合并 A/B 或 B/C，取决于哪种合并方式生成的 run 更短</li><li>如果 A &gt; B + C 或 B &lt;= C，则合并 B/C</li></ul><img src="`+a+'" width="30%"><p>参考链接：</p><ul><li><a href="https://v8.dev/blog/array-sort" target="_blank" rel="noreferrer">https://v8.dev/blog/array-sort</a></li><li><a href="https://github.com/python/cpython/blob/main/Objects/listsort.txt" target="_blank" rel="noreferrer">https://github.com/python/cpython/blob/main/Objects/listsort.txt</a></li><li><a href="https://github.com/python/cpython/blob/main/Objects/listobject.c" target="_blank" rel="noreferrer">https://github.com/python/cpython/blob/main/Objects/listobject.c</a></li><li><a href="https://sikasjc.github.io/2018/07/25/timsort/" target="_blank" rel="noreferrer">https://sikasjc.github.io/2018/07/25/timsort/</a></li></ul>',35),p=[r];function e(i,c,d,u,y,F){return l(),s("div",null,p)}const D=n(o,[["render",e]]);export{m as __pageData,D as default};
