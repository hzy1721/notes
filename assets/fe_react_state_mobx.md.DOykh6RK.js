import{_ as t,c as a,o as e,a1 as s}from"./chunks/framework.mNpZ2GHZ.js";const u=JSON.parse('{"title":"Mobx","description":"","frontmatter":{},"headers":[],"relativePath":"fe/react/state/mobx.md","filePath":"fe/react/state/mobx.md","lastUpdated":1720452437000}'),d={name:"fe/react/state/mobx.md"},i=s(`<h1 id="mobx" tabindex="-1">Mobx <a class="header-anchor" href="#mobx" aria-label="Permalink to &quot;Mobx&quot;">​</a></h1><p>最佳实践：<code>class</code> + <code>makeAutoObservable</code></p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DemoStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /** state */</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  counter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    makeAutoObservable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /** action */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  increase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /** computed */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  get</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> counterPlusOne</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="术语表" tabindex="-1">术语表 <a class="header-anchor" href="#术语表" aria-label="Permalink to &quot;术语表&quot;">​</a></h2><table tabindex="0"><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td>state</td><td>状态</td></tr><tr><td>action</td><td>修改 state 的函数</td></tr><tr><td>derivation</td><td>包括三种：computed、带参数的 &quot;computed&quot;、reaction</td></tr><tr><td>computed</td><td>依赖 state 的 get 属性</td></tr><tr><td>带参数的 &quot;computed&quot;</td><td>依赖 state、带参数、返回值的函数，不能标记为 computed</td></tr><tr><td>reaction</td><td>依赖 state、不返回值的副作用函数</td></tr></tbody></table><table tabindex="0"><thead><tr><th>derivation</th><th>依赖 state</th><th>带参数</th><th>返回值</th></tr></thead><tbody><tr><td>computed</td><td>✅</td><td>❌</td><td>✅</td></tr><tr><td>带参数的 &quot;computed&quot;</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>reaction</td><td>✅</td><td>❔</td><td>❌</td></tr></tbody></table><h2 id="makeautoobservable" tabindex="-1">makeAutoObservable <a class="header-anchor" href="#makeautoobservable" aria-label="Permalink to &quot;makeAutoObservable&quot;">​</a></h2><p><code>makeAutoObservable(target, overrides?, options?)</code></p><p>推导规则：</p><ul><li>自由属性：observable</li><li>get 属性：computed</li><li>set 属性：action</li><li>方法：autoAction</li><li>迭代器：flow</li></ul><h3 id="overrides" tabindex="-1">overrides <a class="header-anchor" href="#overrides" aria-label="Permalink to &quot;overrides&quot;">​</a></h3><table tabindex="0"><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td><code>false</code></td><td>不转换为响应式，主要用于 makeAutoObservable</td></tr><tr><td><code>autoAction</code></td><td>运行时根据调用上下文决定是 action 还是 derivation</td></tr></tbody></table><h3 id="options" tabindex="-1">options <a class="header-anchor" href="#options" aria-label="Permalink to &quot;options&quot;">​</a></h3><table tabindex="0"><thead><tr><th>选项</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td><code>autoBind</code></td><td>使用 <code>action.bound</code>/<code>flow.bound</code> 而不是 <code>action</code>/<code>flow</code></td><td><code>true</code></td></tr><tr><td><code>deep</code></td><td>使用 <code>observable.ref</code> 而不是 <code>observable</code></td><td><code>false</code></td></tr><tr><td><code>name</code></td><td>调试用的名称</td><td></td></tr></tbody></table><h2 id="makeobservable" tabindex="-1">makeObservable <a class="header-anchor" href="#makeobservable" aria-label="Permalink to &quot;makeObservable&quot;">​</a></h2><p><code>makeObservable(target, annotations?, options?)</code></p><h3 id="state" tabindex="-1">state <a class="header-anchor" href="#state" aria-label="Permalink to &quot;state&quot;">​</a></h3><table tabindex="0"><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td><code>observable</code> 等价于 <code>observable.deep</code></td><td>深响应</td></tr><tr><td><code>observable.ref</code></td><td>只有重新赋值会响应</td></tr><tr><td><code>observable.shallow</code></td><td>浅响应 (只有一层)</td></tr><tr><td><code>observable.struct</code></td><td>只有值不同才会响应</td></tr></tbody></table><h3 id="action" tabindex="-1">action <a class="header-anchor" href="#action" aria-label="Permalink to &quot;action&quot;">​</a></h3><table tabindex="0"><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td><code>action</code></td><td>修改 state 的方法</td></tr><tr><td><code>action.bound</code></td><td>绑定 this 为当前实例</td></tr></tbody></table><h3 id="computed" tabindex="-1">computed <a class="header-anchor" href="#computed" aria-label="Permalink to &quot;computed&quot;">​</a></h3><table tabindex="0"><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td><code>computed</code></td><td>依赖 state 的 get 访问器属性</td></tr><tr><td><code>computed.struct</code></td><td>只有值不同才会响应</td></tr></tbody></table><h3 id="flow" tabindex="-1">flow <a class="header-anchor" href="#flow" aria-label="Permalink to &quot;flow&quot;">​</a></h3><table tabindex="0"><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td><code>flow</code></td><td>用于管理异步进程</td></tr><tr><td><code>flow.bound</code></td><td>绑定 this 为当前实例</td></tr></tbody></table><h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h3><table tabindex="0"><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td><code>true</code></td><td>自动推导，相当于 makeAutoObservable</td></tr><tr><td><code>false</code></td><td>不转换为响应式，主要用于 makeAutoObservable</td></tr><tr><td><code>override</code></td><td>重写父类 action/computed</td></tr><tr><td><code>autoAction</code></td><td>运行时根据调用上下文决定是 action 还是 derivation</td></tr></tbody></table><h2 id="observable-vanilla" tabindex="-1">observable -&gt; vanilla <a class="header-anchor" href="#observable-vanilla" aria-label="Permalink to &quot;observable -&gt; vanilla&quot;">​</a></h2><ul><li>浅转换：浅拷贝 <ul><li><code>{ ...observableObject }</code></li><li><code>observableArray.slice()</code></li><li><code>new Map(observableMap)</code></li></ul></li><li>深转换：<code>toJS(observableObject/Array/Map)</code></li></ul>`,28),o=[i];function l(r,n,h,c,p,b){return e(),a("div",null,o)}const E=t(d,[["render",l]]);export{u as __pageData,E as default};
