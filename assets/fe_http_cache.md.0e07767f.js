import{_ as e,c as a,o as c,d as o}from"./app.c431fedc.js";const d="/assets/cache-vary.cfca378a.png",C=JSON.parse('{"title":"缓存","description":"","frontmatter":{},"headers":[{"level":2,"title":"缓存类型","slug":"缓存类型","link":"#缓存类型","children":[{"level":3,"title":"proxy cache","slug":"proxy-cache","link":"#proxy-cache","children":[]},{"level":3,"title":"managed cache","slug":"managed-cache","link":"#managed-cache","children":[]}]},{"level":2,"title":"启发式缓存","slug":"启发式缓存","link":"#启发式缓存","children":[]},{"level":2,"title":"缓存状态","slug":"缓存状态","link":"#缓存状态","children":[]},{"level":2,"title":"Expires","slug":"expires","link":"#expires","children":[]},{"level":2,"title":"Vary","slug":"vary","link":"#vary","children":[]},{"level":2,"title":"revalidation","slug":"revalidation","link":"#revalidation","children":[{"level":3,"title":"If-Modified-Since","slug":"if-modified-since","link":"#if-modified-since","children":[]},{"level":3,"title":"ETag/If-None-Match","slug":"etag-if-none-match","link":"#etag-if-none-match","children":[]}]},{"level":2,"title":"no-cache","slug":"no-cache","link":"#no-cache","children":[]},{"level":2,"title":"no-store","slug":"no-store","link":"#no-store","children":[]},{"level":2,"title":"public","slug":"public","link":"#public","children":[]},{"level":2,"title":"private","slug":"private","link":"#private","children":[]},{"level":2,"title":"强缓存","slug":"强缓存","link":"#强缓存","children":[]},{"level":2,"title":"协商缓存","slug":"协商缓存","link":"#协商缓存","children":[]}],"relativePath":"fe/http/cache.md"}'),i={name:"fe/http/cache.md"},n=o(`<h1 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-hidden="true">#</a></h1><p>HTTP 缓存指的是保存某个请求的响应报文，后续有相同请求直接返回存储的响应。</p><p>缓存有很多优点：</p><ul><li>减少响应时间，直接从缓存读取比请求服务器要快得多，优化用户体验</li><li>降低服务器负载，服务器无需处理被缓存的请求，提升网站性能</li><li>减少冗余的数据传输，节省带宽</li></ul><h2 id="缓存类型" tabindex="-1">缓存类型 <a class="header-anchor" href="#缓存类型" aria-hidden="true">#</a></h2><p>缓存分为 2 大类：</p><ul><li>私有缓存 (private cache) <ul><li>局限于单个客户端 (浏览器)</li><li>使用响应头 <code>Cache-Control: private</code> 指定</li><li>如果响应头包含 <code>Authorization</code>，该响应无法被缓存</li></ul></li><li>共享缓存 (shared cache) <ul><li>存储在客户端和服务端之间的某个地方</li><li>分为 proxy cache 和 managed cache</li></ul></li></ul><h3 id="proxy-cache" tabindex="-1">proxy cache <a class="header-anchor" href="#proxy-cache" aria-hidden="true">#</a></h3><p>客户端和服务端之间的代理服务器为了降低网络流量，会缓存一部分报文。服务端需要正确配置响应头，确保只缓存指定的报文。</p><p>为了兼容旧版本的代理服务器，有以下写法：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Cache-Control: no-store, no-cache, max-age=0, must-revalidate, proxy-revalidate</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>由于 HTTPS 的流行，报文都被加密，代理服务器看不到报文内容，也无法对报文进行缓存，不必担心代理服务器会缓存不想被缓存的报文。</p><h3 id="managed-cache" tabindex="-1">managed cache <a class="header-anchor" href="#managed-cache" aria-hidden="true">#</a></h3><p>服务端部署的缓存，用于降低服务器负载，比如 CDN、反向代理等。</p><p>由于这些缓存由服务端管理，不必遵循 HTTP 缓存规则，能够实现更灵活的缓存管理，比如删除缓存、用响应头禁用缓存而只使用 managed cache 等。</p><p>综上，缓存有 private cache、proxy cache、managed cache。</p><h2 id="启发式缓存" tabindex="-1">启发式缓存 <a class="header-anchor" href="#启发式缓存" aria-hidden="true">#</a></h2><p>启发式缓存 (heuristic caching) 是在 <code>Cache-Control</code> 出现前的一种临时方法，指的是 HTTP 应该尽可能多地缓存报文。</p><p>如果响应头包含 <code>Last-Modified</code> 并且最后修改的日期距现在有较长时间，则可以缓存该报文，有效时间设为相距时间的 10%。比如报文有 1 年没有修改了，则缓存的有效期设为 0.1 年。</p><p>这种方法不够准确，目前已经被 <code>Cache-Control</code> 替代，<strong>所有</strong>响应报文都应该加上 <code>Cache-Control</code> 头部。</p><h2 id="缓存状态" tabindex="-1">缓存状态 <a class="header-anchor" href="#缓存状态" aria-hidden="true">#</a></h2><p>缓存有 2 种状态：fresh (没过期/新鲜) 和 stale (过期/不新鲜)。</p><p><code>Cache-Control</code> 中往往会指定 <code>max-age</code>，以秒为单位的整数。客户端会缓存该报文，并记录 <code>max-age</code> 和响应生成的时间 <code>Date</code>。</p><p>当请求命中缓存时，计算当前时间与响应生成时间的差值，如果超过了 <code>max-age</code>，则缓存过期 (stale)，否则没过期 (fresh)，可以直接返回。</p><p>如果客户端和服务端之间存在 proxy cache，则代理服务器还需要在 <code>Age</code> 字段发回已经缓存的时间。比如 <code>max-age</code> 是 7 天，<code>Age</code> 是 1 天，则客户端缓存的时候需要设置 <code>max-age</code> 为 6 天。</p><h2 id="expires" tabindex="-1">Expires <a class="header-anchor" href="#expires" aria-hidden="true">#</a></h2><p>HTTP/1.0 时期经常用 <code>Expires</code> 指定缓存过期的时间，但是有以下缺点：</p><ul><li>时间字符串比较难解析，有很多实现 bug</li><li>可以通过修改系统时钟影响缓存的有效性</li></ul><p>HTTP/1.1 采用了 <code>Cache-Control</code> 中的 <code>max-age</code>，相比 <code>Expires</code> 实现更方便、安全，完全可以替代 <code>Expires</code>。如果 <code>Expires</code> 和 <code>max-age</code> 同时指定，会优先采取 <code>max-age</code>。</p><h2 id="vary" tabindex="-1">Vary <a class="header-anchor" href="#vary" aria-hidden="true">#</a></h2><p>缓存默认通过 URL 进行区分，相同的 URL 会返回相同的缓存，但很多情况不是这样。比如通过 <code>Accept</code>、<code>Accept-Language</code>、<code>Accept-Encoding</code> 进行内容协商，不同的请求头会返回不同的内容，应该分开缓存。</p><p>可以在 <code>Vary</code> 中指定缓存的 key，比如：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Vary: Accept-Language</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>缓存查找时就会同时考虑 URL 和 <code>Accept-Language</code> 的值。</p><p><img src="`+d+`" alt=""></p><h2 id="revalidation" tabindex="-1">revalidation <a class="header-anchor" href="#revalidation" aria-hidden="true">#</a></h2><p>处于 stale 状态的报文并不会被立即丢弃，而是要通过一个<strong>重新验证 (revalidation)</strong> 的过程，确认这条缓存是否可以继续使用。</p><h3 id="if-modified-since" tabindex="-1">If-Modified-Since <a class="header-anchor" href="#if-modified-since" aria-hidden="true">#</a></h3><p>当请求命中一条过期的缓存时，会发送包含 <code>If-Modified-Since</code> 请求头的报文，值为缓存报文的生成时间 <code>Date</code>。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">GET /index.html HTTP/1.1</span></span>
<span class="line"><span style="color:#A6ACCD;">Host: example.com</span></span>
<span class="line"><span style="color:#A6ACCD;">Accept: text/html</span></span>
<span class="line"><span style="color:#A6ACCD;">If-Modified-Since: Tue, 22 Feb 2022 22:00:00 GMT</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>如果响应未改变，服务端会返回 <code>304 Not Modified</code>，并带上 <code>Last-Modified</code> 和 <code>max-age</code>。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">HTTP/1.1 304 Not Modified</span></span>
<span class="line"><span style="color:#A6ACCD;">Content-Type: text/html</span></span>
<span class="line"><span style="color:#A6ACCD;">Date: Tue, 22 Feb 2022 23:22:22 GMT</span></span>
<span class="line"><span style="color:#A6ACCD;">Last-Modified: Tue, 22 Feb 2022 22:00:00 GMT</span></span>
<span class="line"><span style="color:#A6ACCD;">Cache-Control: max-age=3600</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>缓存被重新设置为 fresh，作为响应报文被返回。</p><p>但是，使用最后修改时间来判断资源是否已经改变有以下问题：</p><ul><li>部分文件会周期性修改，但是内容不一定变化</li><li>部分文件修改非常频繁，以秒为粒度的 <code>Last-Modified</code> 无法准确描述</li><li>一些文件系统无法精确得到文件的修改事件</li></ul><p><code>ETag</code> 是一种解决方案。</p><h3 id="etag-if-none-match" tabindex="-1">ETag/If-None-Match <a class="header-anchor" href="#etag-if-none-match" aria-hidden="true">#</a></h3><p><code>ETag</code> 响应头是由服务端生成的、能够区分资源是否被修改的字符串，比如响应体的哈希值、版本号等。</p><p>当缓存过期时，把 <code>ETag</code> 的值放入请求头 <code>If-None-Match</code> 中，询问服务端该资源的 <code>ETag</code> 是否被修改。</p><ul><li>如果资源未被修改，服务端返回 <code>304 Not Modified</code>。</li><li>如果资源的 <code>ETag</code> 改变，服务端返回 <code>200 OK</code>，响应体是资源的最新版本</li></ul><p>如果 <code>ETag</code> 和 <code>Last-Modified</code> 同时存在，优先使用 <code>ETag</code>。尽管 <code>Last-Modified</code> 不如 <code>ETag</code> 好用，但是 <code>Last-Modified</code> 还有缓存之外的其他用途，包括 CMS (Content Management System)、爬虫等。所以最好把 <code>Last-Modified</code> 和 <code>ETag</code> 都加上。</p><p>浏览器调试工具中可以看到缓存有 2 种：from memory/disk cache。如果响应有 <code>ETag</code>，就会被写入磁盘。</p><h2 id="no-cache" tabindex="-1">no-cache <a class="header-anchor" href="#no-cache" aria-hidden="true">#</a></h2><p><code>Cache-Control: no-cache</code> 表示每次请求都验证缓存的有效性，也就是不使用强缓存，每次都协商缓存。</p><p>如果请求头包含 <code>If-Modified-Since</code> 或 <code>If-None-Match</code>，客户端会在资源未更新时收到 <code>304 Not Modified</code>，资源已更新时收到 <code>200 OK</code>。</p><p><code>no-cache</code> 不禁止响应报文的缓存，只是要求每次都验证资源有效性。</p><h2 id="no-store" tabindex="-1">no-store <a class="header-anchor" href="#no-store" aria-hidden="true">#</a></h2><p>如果想完全禁止响应报文的缓存，使用 <code>Cache-Control: no-store</code>。</p><p><code>no-store</code> 禁止缓存新响应，但无法禁止旧缓存的使用，如果想在每次请求时都提供最新的内容，应该使用 <code>no-cache</code>。</p><p><code>no-store</code> 由于禁止存储报文，会造成很多负面影响，最好使用 <code>no-cache, private</code> 来代替。</p><h2 id="public" tabindex="-1">public <a class="header-anchor" href="#public" aria-hidden="true">#</a></h2><p><code>Cache-Control: public</code> 表示资源可以被所有客户端缓存，包括用户浏览器和代理服务器。</p><h2 id="private" tabindex="-1">private <a class="header-anchor" href="#private" aria-hidden="true">#</a></h2><p><code>Cache-Control: private</code> 表示资源只能被用户浏览器缓存，不能被代理服务器缓存。</p><h2 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-hidden="true">#</a></h2><p>本地缓存命中且未过期，直接返回本地缓存的资源。</p><h2 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a></h2><p>缓存已过期，带上 <code>If-Modified-Since</code> 或 <code>If-None-Match</code> 请求服务端。</p><p>如果资源未修改，则返回 <code>304 Not Modified</code>，重新设置缓存有效时间，返回本地缓存资源。</p><p>如果资源已修改，<code>Last-Modified</code> 晚于 <code>If-Modified-Since</code> 或者 <code>ETag</code> 与 <code>If-None-Match</code> 不同，返回 <code>200 OK</code> 和资源的最新版本。</p>`,70),l=[n];function s(t,p,r,h,g,u){return c(),a("div",null,l)}const x=e(i,[["render",s]]);export{C as __pageData,x as default};
