import{_ as s,c as n,o as a,U as l}from"./chunks/framework.e548c890.js";const p="/assets/closure_variable.2be94562.png",o="/assets/closure_function.14addbf1.png",e="/assets/closure_outer.e0dc139d.png",g=JSON.parse('{"title":"闭包","description":"","frontmatter":{},"headers":[],"relativePath":"fe/lang/js/function/closure.md","filePath":"fe/lang/js/function/closure.md","lastUpdated":1702822707000}'),t={name:"fe/lang/js/function/closure.md"},c=l('<h1 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h1><p>闭包 (closure) 是指函数声明时会绑定外部环境，无论传递到哪里调用，函数内都能访问到<strong>声明时</strong>的外部变量 (外部环境)。</p><p>通常用于函数一等公民的编程语言。</p><h2 id="作用域与词法环境" tabindex="-1">作用域与词法环境 <a class="header-anchor" href="#作用域与词法环境" aria-label="Permalink to &quot;作用域与词法环境&quot;">​</a></h2><p>变量有 3 种作用域，只在所处的作用域中可见：</p><ul><li>全局作用域</li><li>函数作用域</li><li>块作用域</li></ul><p>每个作用域有一个称为<strong>词法环境 (Lexical Environment)</strong> 的隐藏对象。</p><p>词法环境有 2 部分：</p><ul><li>环境记录 (Environment Record)：作用域内所有局部变量</li><li>对外部词法环境的引用 (全局词法环境无外部引用)</li></ul><p>对于<strong>变量</strong>来说，词法环境预先读取所有声明的变量，设为未初始化 (Uninitialized) 状态，在遇到声明之前不能引用，就像该变量不存在一样。遇到声明语句后，变量可以被读取和修改。</p><p><img src="'+p+'" alt=""></p><p>对于<strong>函数</strong>来说，词法环境会预先<strong>读取并初始化</strong>所有声明的函数，允许调用下方声明的函数。</p><p><img src="'+o+'" alt=""></p><p>访问变量时，首先搜索当前作用域的词法环境，其次是外部以及更外部，直到全局。</p><p>如果都没找到，严格模式下报错，非严格模式下会声明一个全局变量。</p><h2 id="闭包-1" tabindex="-1">闭包 <a class="header-anchor" href="#闭包-1" aria-label="Permalink to &quot;闭包&quot;">​</a></h2><p>函数作用域也有自己的词法环境，使用 <code>[[Environment]]</code> 隐藏属性存储对外部环境的引用，创建函数时会自动设置这个属性。</p><p>不管这个函数被传递到什么地方调用，调用时的外部词法环境永远是<strong>声明时</strong>的外部环境，与调用时的外部环境无关，保证了函数的可用性。</p><p><img src="'+e+`" alt=""></p><h2 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h2><p>任何需要访问函数外变量的场景，核心是创建私有变量、延长变量的生命周期。</p><ol><li>各种回调函数 <ul><li>setTimeout</li><li>addEventListener</li></ul></li><li>返回函数的函数，返回的函数需要访问函数内声明的变量 <ul><li>防抖、节流</li><li>柯里化</li></ul></li><li>模拟私有属性和方法：IIFE 返回公有方法，需要访问 IIFE 函数内的私有属性和方法</li><li>解决 var 没有块作用域的问题 <ul><li>外面包一层 IIFE 传入参数来固定 var 变量的值</li></ul></li></ol><h2 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h2><p>函数执行结束后，如果没有其他环境引用这个函数环境，该环境会从内存中删除（垃圾回收）。</p><p>对于返回函数的函数，由于返回的函数引用了外部函数的词法环境，就不会发生垃圾回收，直到返回的函数不再使用，才会回收外部函数。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">f</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">123</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// g 函数存在时，f 不会被回收</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> g </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">f</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// g 和 f 都可以回收了</span></span>
<span class="line"><span style="color:#A6ACCD;">g </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span></code></pre></div><p>目前主流的 V8 引擎会对这种情况做一些优化，如果返回的函数<strong>没有引用外部环境的任何变量</strong>，则会将外部函数从外部环境链上删除，并允许回收外部函数。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Surprise!</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">f</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">the closest value</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">g</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 在 Console 中输入 value 会显示 &quot;Surprise!&quot;，意味着 f 被回收了</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#F78C6C;">debugger</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">g</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> g </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">f</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">g</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span></code></pre></div>`,28),r=[c];function i(F,y,D,A,u,C){return a(),n("div",null,r)}const h=s(t,[["render",i]]);export{g as __pageData,h as default};
