import{_ as l,c as i,o as e,d as t}from"./app.32a4a0ab.js";const a="/assets/build-tool.6eb3624d.png",f=JSON.parse('{"title":"前端构建工具","description":"","frontmatter":{},"headers":[{"level":2,"title":"模块规范","slug":"模块规范","link":"#模块规范","children":[]},{"level":2,"title":"Webpack 与 Vite 的区别","slug":"webpack-与-vite-的区别","link":"#webpack-与-vite-的区别","children":[]}],"relativePath":"fe/framework/vite/build-tool.md","lastUpdated":1680318810000}'),o={name:"fe/framework/vite/build-tool.md"},r=t('<h1 id="前端构建工具" tabindex="-1">前端构建工具 <a class="header-anchor" href="#前端构建工具" aria-hidden="true">#</a></h1><p><img src="'+a+'" alt=""></p><h2 id="模块规范" tabindex="-1">模块规范 <a class="header-anchor" href="#模块规范" aria-hidden="true">#</a></h2><ul><li>CommonJS <ul><li>最早提出</li><li>主要用于 Node 服务端</li><li>浏览器需要使用 browserify 打包</li><li>同步阻塞的方式加载模块，不太适合在浏览器中运行</li></ul></li><li>AMD (Asynchronous Module Definition) <ul><li>异步加载模块，解决了 CommonJS 的同步阻塞问题</li><li>需要使用 requireJS 打包</li><li>语法复杂，阅读和书写都比较困难</li><li>仅仅是一个妥协性的方案</li></ul></li><li>CMD (Common Module Definition) <ul><li>阿里在 SeaJS 中提出</li><li>与 AMD 类似，语法更简单一点</li></ul></li><li>UMD (Universal Module Definition) <ul><li>兼容 CommonJS 和 AMD 的一种方案</li><li>可以同时运行在浏览器和 Node 环境</li></ul></li><li>ESM (ES6 Module) <ul><li>ES 官方提出的模块规范，被现代浏览器原生支持</li><li>兼容性较好，覆盖了 90% 以上的浏览器份额</li><li>Node 12.20+ 原生支持 ESM</li><li>能够同时在浏览器和 Node 中执行，天然跨平台</li></ul></li></ul><h2 id="webpack-与-vite-的区别" tabindex="-1">Webpack 与 Vite 的区别 <a class="header-anchor" href="#webpack-与-vite-的区别" aria-hidden="true">#</a></h2><ul><li>冷启动 <ul><li>Webpack <ul><li>递归打包整个项目的依赖树</li><li>使用 JS 编写，有性能瓶颈</li></ul></li><li>Vite <ul><li>使用 esbuild 预构建第三方依赖，使用 Go 编写，速度更快</li><li>源码按需编译为 ESM 提供给浏览器</li></ul></li></ul></li></ul>',6),d=[r];function n(s,u,c,_,h,p){return e(),i("div",null,d)}const b=l(o,[["render",n]]);export{f as __pageData,b as default};
