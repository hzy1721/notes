import{_ as l,c as e,o as i,d as o}from"./app.71c38c5d.js";const v=JSON.parse('{"title":"变量声明","description":"","frontmatter":{},"headers":[{"level":2,"title":"var","slug":"var","link":"#var","children":[]},{"level":2,"title":"let","slug":"let","link":"#let","children":[]},{"level":2,"title":"const","slug":"const","link":"#const","children":[]},{"level":2,"title":"顶层变量","slug":"顶层变量","link":"#顶层变量","children":[]}],"relativePath":"fe/basic/js/variable.md","lastUpdated":1682650439000}'),c={name:"fe/basic/js/variable.md"},a=o('<h1 id="变量声明" tabindex="-1">变量声明 <a class="header-anchor" href="#变量声明" aria-hidden="true">#</a></h1><p>有 6 种声明变量的方法：</p><ul><li><code>var</code></li><li><code>function</code></li><li><code>let</code></li><li><code>const</code></li><li><code>import</code></li><li><code>class</code></li></ul><h2 id="var" tabindex="-1">var <a class="header-anchor" href="#var" aria-hidden="true">#</a></h2><ul><li>ES5 声明变量的方法，不支持常量</li><li>只有<strong>函数作用域</strong>和<strong>全局作用域</strong>，没有块作用域</li><li>变量的声明和赋值会分开，声明会<strong>提升</strong>到作用域顶部</li><li>不声明直接赋值的变量会声明为<strong>全局变量</strong></li><li>缺点： <ul><li>块作用域内层变量覆盖外层变量</li><li>循环变量泄漏为外层变量</li></ul></li><li>通常使用 IIFE 实现块作用域 <ul><li>Immediately Invoked Function Expression</li></ul></li></ul><h2 id="let" tabindex="-1">let <a class="header-anchor" href="#let" aria-hidden="true">#</a></h2><ul><li>ES6 声明变量的方法，具有块作用域</li><li>for 循环中的循环变量与循环体内部的变量有各自单独的作用域</li><li>只能在声明后使用 <ul><li>块作用域内一旦有 let 和 const 声明，声明前的部分都不能访问对应的变量，即使存在同名的全局变量</li><li>作用域开头与声明之间的区域称为 Temporal Dead Zone (TDZ)，为了确保不在变量声明之前使用变量</li></ul></li><li>不允许在同一作用域内重复声明</li><li>块作用域必须加花括号，没有花括号就不存在块作用域，编写 ES6 代码应避免省略花括号</li></ul><h2 id="const" tabindex="-1">const <a class="header-anchor" href="#const" aria-hidden="true">#</a></h2><ul><li>ES6 声明常量的方法，必须立即初始化</li><li><code>let</code> 的大部分规则也适用于 <code>const</code></li><li>保证常量所在内存地址的数据不被修改 <ul><li>对于原始类型表示值不会改变</li><li>对于对象类型表示指向的对象不会改变，但对象内部的属性是可以修改的</li><li>如果想让对象的属性也不可修改，可以使用 <code>Object.freeze</code><ul><li>冻结后的对象不能新增和删除属性，已有的属性也不能修改</li><li>如果对象的属性也有可能是对象，为了完全冻结，可以递归应用 <code>Object.freeze</code></li></ul></li></ul></li></ul><h2 id="顶层变量" tabindex="-1">顶层变量 <a class="header-anchor" href="#顶层变量" aria-hidden="true">#</a></h2><ul><li>顶层变量在浏览器中是 <code>window</code>，在 Node 中是 <code>global</code></li><li>ES5 中顶层变量的属性与全局变量等价</li><li>ES6 中 <ul><li><code>var</code> 和 <code>function</code> 声明的全局变量与顶层变量的属性等价</li><li><code>let</code>、<code>const</code>、<code>class</code> 声明的全局变量不属于顶层变量的属性</li></ul></li><li>由于变量名不同等因素，很难找到一种方法在所有情况下都取到顶层对象 <ul><li>ES2020 引入了 <code>globalThis</code>，在所有环境下都能取到，指向全局环境下的 <code>this</code></li></ul></li></ul>',11),d=[a];function t(r,n,s,h,u,_){return i(),e("div",null,d)}const p=l(c,[["render",t]]);export{v as __pageData,p as default};
