import{_ as l,c as e,o as i,a1 as a}from"./chunks/framework.mNpZ2GHZ.js";const m=JSON.parse('{"title":"服务端组件","description":"","frontmatter":{},"headers":[],"relativePath":"fe/react/next/server-component.md","filePath":"fe/react/next/server-component.md","lastUpdated":1704115023000}'),t={name:"fe/react/next/server-component.md"},o=a('<h1 id="服务端组件" tabindex="-1">服务端组件 <a class="header-anchor" href="#服务端组件" aria-label="Permalink to &quot;服务端组件&quot;">​</a></h1><p>SSR 组件，Next 的默认模式。</p><p>服务端渲染有以下优点：</p><ul><li>接口请求离服务端更近，耗时更少</li><li>敏感数据和逻辑可以保留在服务端</li><li>服务端可以缓存不同用户的多个请求，减少响应时间</li><li>减小客户端包大小</li><li>有利于 SEO 和分享</li></ul><p>最终实现：</p><ul><li>更快的首屏加载（LCP、FCP 等指标）</li><li>更好的用户体验</li></ul><h2 id="渲染流程" tabindex="-1">渲染流程 <a class="header-anchor" href="#渲染流程" aria-label="Permalink to &quot;渲染流程&quot;">​</a></h2><ol><li>根据路由和 Suspense 将应用分为 chunk</li><li>每个 chunk 分为服务端和客户端两步渲染 <ol><li>服务端： <ol><li>React 把组件渲染为 RSC Payload</li><li>Next 基于 RSC Payload 渲染 HTML</li></ol></li><li>客户端： <ol><li>很快显示一个不可交互的 HTML 页面</li><li>基于 RSC Payload 协调服务端和客户端的组件树</li><li>注水（事件处理）使页面可交互</li></ol></li></ol></li></ol><h2 id="渲染策略" tabindex="-1">渲染策略 <a class="header-anchor" href="#渲染策略" aria-label="Permalink to &quot;渲染策略&quot;">​</a></h2><ul><li>静态渲染（static，默认） <ul><li>编译时渲染路由，输出静态页面，可以缓存、上传 CDN</li><li>适合与请求无关的页面，比如博客、展示页</li></ul></li><li>动态渲染（dynamic） <ul><li>请求时渲染路由</li><li>适合与请求相关的页面，比如根据 search param 展示不同内容</li></ul></li><li>流式渲染（streaming） <ul><li>把页面分为多个 chunk，并行加载和展示</li></ul></li></ul>',10),r=[o];function n(c,s,d,u,_,h){return i(),e("div",null,r)}const f=l(t,[["render",n]]);export{m as __pageData,f as default};
