import{_ as l,c as i,o as a,a1 as t}from"./chunks/framework.mNpZ2GHZ.js";const e="/assets/tcp-header.DEQc7lls.png",o="/assets/three-handshake.BDNVrcHQ.png",s="/assets/four-wave.DJFZLyJt.png",r="/assets/congestion-control.YDUwCf97.png",S=JSON.parse('{"title":"TCP","description":"","frontmatter":{},"headers":[],"relativePath":"basic/network/tcp.md","filePath":"basic/network/tcp.md","lastUpdated":1695698588000}'),n={name:"basic/network/tcp.md"},c=t('<h1 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h1><h2 id="报文格式" tabindex="-1">报文格式 <a class="header-anchor" href="#报文格式" aria-label="Permalink to &quot;报文格式&quot;">​</a></h2><p><img src="'+e+'" alt=""></p><h2 id="连接建立" tabindex="-1">连接建立 <a class="header-anchor" href="#连接建立" aria-label="Permalink to &quot;连接建立&quot;">​</a></h2><ol><li>客户端、服务端都处于 CLOSED 状态</li><li>服务端启动后进入 LISTEN 状态，监听客户端请求</li><li>客户端需要建立连接时，发送请求报文 <ul><li>SYN 置 1</li><li>起始序号为 x</li><li>然后进入 SYN-SENT 状态（SYN 报文已发送）</li></ul></li><li>服务端接收到请求报文，发回响应报文 <ul><li>SYN 置 1</li><li>起始序号为 y</li><li>ACK 置 1</li><li>ack 为 x + 1</li><li>然后进入 SYN-RCVD 状态（SYN 报文已收到）</li></ul></li><li>客户端接收到响应报文，发回确认报文 <ul><li>序号为 x + 1</li><li>ACK 置 1</li><li>ack 为 y + 1</li><li>然后进入 ESTABLISHED 状态（连接建立）</li></ul></li><li>服务端接收到确认报文，也进入 ESTABLISHED 状态（连接建立）</li></ol><p><img src="'+o+'" alt=""></p><p>注意点：</p><ul><li>只有前两个报文 SYN 置 1</li><li>客户端和服务端的序号相互独立</li><li>第二个报文开始 ACK 都置 1、ack 为上一个收到报文的序号 + 1</li></ul><p><strong>Q：</strong> 为什么需要第三次握手，而不是两次？</p><p><strong>A：</strong> 防止滞留的连接请求到达服务端，造成服务端错误地打开连接。</p><ul><li>比如客户端发送的第 1 个连接请求报文滞留在网络中但没有丢失，客户端未收到响应一段时间后超时重传，最终完成三次握手建立连接，但是滞留的请求报文最终到达了服务端</li><li>如果只有两次握手，服务端收到请求就会打开连接，可能打开不需要的连接，造成资源浪费</li><li>如果需要三次握手，尽管服务器收到了滞留的请求报文，并发回确认报文，但由于此时客户端不需要建立连接，不会发回第 3 个确认报文，TCP 连接就无法建立</li></ul><h2 id="连接释放" tabindex="-1">连接释放 <a class="header-anchor" href="#连接释放" aria-label="Permalink to &quot;连接释放&quot;">​</a></h2><ol><li>客户端和服务端都处于 ESTABLISHED 状态</li><li>客户端需要关闭连接时，发送请求报文 <ul><li>FIN 置 1</li><li>起始序号为 u</li><li>然后进入 FIN-WAIT-1 状态（等待服务端的响应报文）</li></ul></li><li>服务端接收到请求报文，发回响应报文 <ul><li>起始序号为 v</li><li>ACK 置 1</li><li>ack 为 u + 1</li><li>然后进入 CLOSE-WAIT 状态（等待服务端关闭到客户端的连接）</li></ul></li><li>客户端接收到响应报文，进入 FIN-WAIT-2 状态（等待服务端的关闭请求报文） <ul><li>客户端到服务端的单向连接已关闭，但服务端还可以继续向客户端发送数据</li></ul></li><li>服务端完成最后的数据传输，发送关闭请求报文 <ul><li>FIN 置 1</li><li>起始序号为 w</li><li>ACK 置 1</li><li>ack 为 u + 1</li><li>然后进入 LAST-ACK 状态（等待最后一个响应报文）</li></ul></li><li>客户端接收到请求报文，发回响应报文 <ul><li>序号为 u + 1</li><li>ACK 置 1</li><li>ack 为 w + 1</li><li>然后进入 TIME-WAIT 状态（等待 2MSL 时间）</li></ul></li><li>服务端接收到响应报文，直接进入 CLOSED 状态</li><li>客户端等待 2MSL 时间后自动进入 CLOSED 状态 <ul><li>MSL：Maximum Segment Lifetime，最大报文存活时间</li></ul></li></ol><p><img src="'+s+'" alt=""></p><p>注意点：</p><ul><li>只有两个关闭请求报文 FIN 置 1</li><li>客户端和服务端的序号相互独立</li><li>第二个报文开始 ACK 都置 1、ack 为上一个收到报文的序号 + 1</li><li>客户端第一个报文和第四个报文的序号相邻，因为中间没有其他报文</li><li>服务端第二个报文和第三个报文的序号不一定相邻，因为中间可能进行数据传输</li></ul><p><strong>Q：</strong> 为什么客户端发送第四个响应报文后，需要等待 2MSL 的时间？</p><p><strong>A：</strong> 原因有 2 个：</p><ol><li>确保第四个确认报文能够到达服务端 <ul><li>如果服务端没收到客户端发送来的确认报文，就会超时重传第三个请求报文</li><li>客户端等待一段时间就是为了处理这种情况，等待期间如果收到重传的请求报文就可以重新发送确认报文</li><li>如果不等待而直接关闭，就会造成服务端收不到第四个响应报文而无法关闭连接</li></ul></li><li>让本连接期间的所有报文都从网络中消失，使下一个连接不会出现旧的报文</li></ol><p>如果客户端关闭连接后，服务端没有数据要发送，可以把第二个和第三个报文合并，也就是变为 “三次挥手” 而不是 “四次挥手”。</p><h2 id="可靠传输" tabindex="-1">可靠传输 <a class="header-anchor" href="#可靠传输" aria-label="Permalink to &quot;可靠传输&quot;">​</a></h2><p>可靠传输的核心是<strong>超时重传</strong>：已发送的报文在指定时间内没有收到确认，就重新发送。</p><p>超时重传时间称为 RTO (Retransmission TimeOut)：</p><blockquote><p>RTO = RTTs + 4 * RTTd</p></blockquote><p>RTTs 是加权平均往返时间，根据每次通信的 RTT 实时更新：</p><blockquote><p>RTTs = (1 - a) * RTTs + a * RTT</p></blockquote><ul><li>初始 RTTs 值为 RTT</li><li>a 是范围 [0, 1) 的参数，a 越大，最新的 RTT 对 RTTs 的影响就越大，推荐值是 1/8</li></ul><p>RTTd 是 RTTs 与 RTT 偏差的加权平均值：</p><blockquote><p>RTTd = (1 - b) * RTTd + b * |RTTs - RTT|</p></blockquote><ul><li>初始 RTTd 值为 RTT 的一半</li><li>b 是范围 [0, 1) 的参数，b 越大，最新的偏差对 RTTd 的影响就越大，推荐值是 1/4</li></ul><p>Karn 算法：</p><ul><li>发生超时重传，说明网络发生了拥塞，应该把 RTO 的值增大一点，避免更多的超时重传，通常增大为原来的 2 倍</li><li>直到不再发生超时重传，继续使用上面的公式计算 RTO</li></ul><h2 id="流量控制" tabindex="-1">流量控制 <a class="header-anchor" href="#流量控制" aria-label="Permalink to &quot;流量控制&quot;">​</a></h2><p>控制发送方的发送速率，使接收方来得及接收 (接收缓存不会溢出)。</p><p>流量控制通过确认报文的窗口字段实现 (接收窗口)，发送窗口的大小不能超过接收窗口。</p><h2 id="拥塞控制" tabindex="-1">拥塞控制 <a class="header-anchor" href="#拥塞控制" aria-label="Permalink to &quot;拥塞控制&quot;">​</a></h2><p>TCP 通过 4 个算法进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><p><img src="'+r+'" alt=""></p><h3 id="慢开始" tabindex="-1">慢开始 <a class="header-anchor" href="#慢开始" aria-label="Permalink to &quot;慢开始&quot;">​</a></h3><ul><li>初始 cwnd = 1，每收到一个确认将 cwnd + 1，每个轮次 cwnd 变为原来的两倍，呈指数增长</li><li>设置慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，转为执行拥塞避免算法</li></ul><h3 id="拥塞避免" tabindex="-1">拥塞避免 <a class="header-anchor" href="#拥塞避免" aria-label="Permalink to &quot;拥塞避免&quot;">​</a></h3><ul><li>每个轮次将 cwnd + 1，呈线性增长</li><li>如果发生超时，说明网络发生了拥塞，将 ssthresh 设为 cwnd / 2，cwnd 设为 1，重新开始执行慢开始算法</li></ul><h3 id="快重传" tabindex="-1">快重传 <a class="header-anchor" href="#快重传" aria-label="Permalink to &quot;快重传&quot;">​</a></h3><ul><li>每收到一个报文，就对目前按序收到的最后一个报文发回确认</li><li>如果发送方连续收到 3 个对同一报文的确认 (3-ACK)，说明该报文的下一个报文已经丢失，立即重传下一个报文，而不是等到超时再重传</li></ul><h3 id="快恢复" tabindex="-1">快恢复 <a class="header-anchor" href="#快恢复" aria-label="Permalink to &quot;快恢复&quot;">​</a></h3><ul><li>发生快重传，只是部分报文丢失，不一定是网络拥塞，将 ssthresh 设为 cwnd / 2，cwnd 设为 ssthresh，执行拥塞避免算法</li></ul>',46),u=[c];function h(p,T,d,b,_,m){return a(),i("div",null,u)}const q=l(n,[["render",h]]);export{S as __pageData,q as default};
