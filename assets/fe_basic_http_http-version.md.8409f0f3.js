import{_ as i,c as l,o as e,d as t}from"./app.f383fb76.js";const g=JSON.parse('{"title":"HTTP 版本","description":"","frontmatter":{},"headers":[{"level":2,"title":"HTTP/0.9","slug":"http-0-9","link":"#http-0-9","children":[]},{"level":2,"title":"HTTP/1.0","slug":"http-1-0","link":"#http-1-0","children":[]},{"level":2,"title":"HTTP/1.1","slug":"http-1-1","link":"#http-1-1","children":[]},{"level":2,"title":"HTTP/2","slug":"http-2","link":"#http-2","children":[]},{"level":2,"title":"HTTP/3","slug":"http-3","link":"#http-3","children":[]}],"relativePath":"fe/basic/http/http-version.md","lastUpdated":1681310459000}'),o={name:"fe/basic/http/http-version.md"},d=t('<h1 id="http-版本" tabindex="-1">HTTP 版本 <a class="header-anchor" href="#http-版本" aria-hidden="true">#</a></h1><h2 id="http-0-9" tabindex="-1">HTTP/0.9 <a class="header-anchor" href="#http-0-9" aria-hidden="true">#</a></h2><ul><li>1991 年发布</li><li>只支持 <code>GET</code> 方法</li><li>只支持 <code>HTML</code> 类型</li><li>请求完成后关闭 TCP 连接</li></ul><h2 id="http-1-0" tabindex="-1">HTTP/1.0 <a class="header-anchor" href="#http-1-0" aria-hidden="true">#</a></h2><ul><li>1996 年发布</li><li>新增 <code>POST</code>、<code>HEAD</code> 方法</li><li>新增 HTTP Header，用于描述元数据，必须是 ASCII 编码</li><li>新增状态码 (Status Code)</li><li>支持图片、视频、二进制文件等多种类型，使用 <code>Content-Type</code> 说明数据格式 <ul><li>总称为 <strong>MIME type</strong>，包含一级类型和二级类型</li><li><code>text/plain</code></li><li><code>text/html</code></li><li><code>text/css</code></li><li><code>image/jpeg</code></li><li><code>image/png</code></li><li><code>image/svg+xml</code></li><li><code>audio/mp4</code></li><li><code>video/mp4</code></li><li><code>application/javascript</code></li><li><code>application/pdf</code></li><li><code>application/zip</code></li><li><code>application/atom+xml</code></li><li>也可以自定义类型</li><li>末尾可以使用分号 <code>;</code> 添加参数，比如 <code>text/html; charset=utf-8</code></li></ul></li><li>客户端请求时使用 <code>Accept</code> 声明接受的 MIME 类型</li><li>支持多字符集</li><li>支持 multi-part type</li><li>支持 Authorization</li><li>支持缓存 (启发式缓存)</li><li>支持数据压缩，使用 <code>Content-Encoding</code> 说明压缩方法</li><li>客户端请求时使用 <code>Accept-Encoding</code> 声明支持的压缩方法</li><li>缺点：一个 TCP 连接只发送一个请求，性能比较差</li><li>部分浏览器请求时使用<strong>非标准</strong>的 <code>Connection: keep-alive</code>，要求服务端不要关闭 TCP 连接，如果服务端也回应 <code>Connection: keep-alive</code>，就建立了一个可复用的 TCP 连接</li></ul><h2 id="http-1-1" tabindex="-1">HTTP/1.1 <a class="header-anchor" href="#http-1-1" aria-hidden="true">#</a></h2><ul><li>1997 年发布</li><li>新增 <code>PUT</code>、<code>PATCH</code>、<code>OPTIONS</code>、<code>DELETE</code> 方法</li><li>请求头新增 <code>Host</code>，指定服务端域名，一个 IP 可以部署多个域名</li><li>引入<strong>持久连接</strong>：TCP 连接默认不关闭，可以被多个请求复用 <ul><li>客户端和服务端发现对方有一段时间没有活动，可以主动关闭连接</li><li>客户端最好发送最后一个请求时带上 <code>Connection: close</code>，告知服务端关闭连接</li><li>同一个域名，大多数浏览器允许同时建立 6 个持久连接</li></ul></li><li>引入<strong>管道机制 (pipelining)</strong>：允许在一个 TCP 连接里同时发送多个请求 <ul><li>一个 TCP 连接可以发送多个回应，为了区分不同的响应报文，使用 <code>Content-Length</code> 指定数据长度，以字节为单位</li><li>对于耗时操作，最好实时发送生成的数据，而不是全部生成再统一发送。使用 <code>Transfer-Encoding: chunked</code> 指定分块传输编码，每个数据块前有一个十六进制数，表示当前数据块的长度，最后是一个长度为 0 的块</li></ul></li><li>缓存</li><li>内容协商</li><li>缺点：服务器按顺序处理请求，如果处理前面的请求耗时过长，就会造成后面的请求排队，称为<strong>队头阻塞</strong> (head-of-line blocking)。</li></ul><h2 id="http-2" tabindex="-1">HTTP/2 <a class="header-anchor" href="#http-2" aria-hidden="true">#</a></h2><ul><li>2015 年发布，基于 Google 2009 年公开的 SPDY 协议 (用于解决 HTTP/1.1 效率不高的问题)</li><li>彻底的<strong>二进制协议</strong>： <ul><li>header 和 body 都是二进制编码，统称为帧 (frame)</li><li>头信息帧、数据帧</li><li>可以定义额外的帧，用于高级应用，解析数据相比文本更方便</li></ul></li><li>引入<strong>头信息压缩 (header compression)</strong>： <ul><li>由于 HTTP 的无状态，每次请求都需要带上很多重复的 header，浪费带宽、影响速度</li><li>header 使用 gzip 或 compress 压缩后再发送</li><li>客户端和服务端维护一张头信息表，所有字段存入该表并生成索引号，后续只发送索引号</li></ul></li><li><strong>多工 (multiplexing)</strong>： <ul><li>双向、实时通信</li><li>一个 TCP 连接中，客户端和服务端都可以同时发送多个请求和响应，并且响应顺序不必对应请求顺序，避免了 head-of-line blocking</li></ul></li><li>由于数据包可以不按顺序发送，需要标记数据包属于哪个请求/响应报文 <ul><li>每个报文的所有数据包称为一个<strong>数据流 (stream)</strong>，有一个<strong>唯一编号</strong>，附加在每个数据包中</li><li>客户端发出的数据流 ID 为奇数，服务端发出的数据流 ID 为偶数</li><li>取消数据流：发送 <code>RST_STREAM</code> 帧</li><li>客户端可以指定数据流的优先级，优先级高服务端更早回应</li></ul></li><li><strong>服务器推送 (server push)</strong>： <ul><li>允许服务端未收到请求就向客户端发送资源</li><li>客户端请求的网页包含很多静态资源，正常情况是客户端解析 HTML 发现静态资源后再请求，服务端可以预期到客户端请求的页面需要这些静态资源，而把静态资源随 HTML 页面一同发给客户端</li></ul></li></ul><h2 id="http-3" tabindex="-1">HTTP/3 <a class="header-anchor" href="#http-3" aria-hidden="true">#</a></h2><p>UDP + QUIC</p>',11),c=[d];function n(a,r,h,s,p,T){return e(),l("div",null,c)}const P=i(o,[["render",n]]);export{g as __pageData,P as default};
