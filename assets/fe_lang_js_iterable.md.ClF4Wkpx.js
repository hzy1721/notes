import{_ as s,c as i,o as a,a1 as l}from"./chunks/framework.mNpZ2GHZ.js";const g=JSON.parse('{"title":"可迭代对象","description":"","frontmatter":{},"headers":[],"relativePath":"fe/lang/js/iterable.md","filePath":"fe/lang/js/iterable.md","lastUpdated":1702822707000}'),e={name:"fe/lang/js/iterable.md"},n=l(`<h1 id="可迭代对象" tabindex="-1">可迭代对象 <a class="header-anchor" href="#可迭代对象" aria-label="Permalink to &quot;可迭代对象&quot;">​</a></h1><p>可迭代对象是可以在 <code>for...of</code> 循环中使用的对象。</p><p>可迭代的内建对象：</p><ul><li><code>String</code></li><li><code>Array</code></li><li><code>Set</code></li><li><code>Map</code></li><li><code>arguments</code></li><li><code>TypedArray</code></li><li><code>NodeList</code></li></ul><p>可以将任何对象通过添加 <code>[Symbol.iterator]</code> 方法变为可迭代对象。</p><h2 id="symbol-iterator" tabindex="-1">Symbol.iterator <a class="header-anchor" href="#symbol-iterator" aria-label="Permalink to &quot;Symbol.iterator&quot;">​</a></h2><p><code>for...of</code> 循环遍历可迭代对象的关键在于对象的 <code>Symbol.iterator</code> 方法。</p><ol><li><code>for...of</code> 循环启动时，调用对象的 <code>Symbol.iterator</code> 方法，返回一个<strong>迭代器 (iterator)</strong>。 <ul><li>迭代器是指拥有 <code>next()</code> 方法的对象。</li><li>可选的 <code>return()</code> 方法在迭代提前退出前调用 (<code>break</code> 或出错)。</li></ul></li><li><code>for...of</code> 调用迭代器的 <code>next()</code> 方法获取下一个值。 <ul><li><code>next()</code> 返回的格式为 <code>{ done: Boolean, value: any }</code>，<code>done: true</code> 表示循环结束</li></ul></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> range </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  from: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  to: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [Symbol.iterator]() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      current: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.from,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      last: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.to,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.last) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { done: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, value: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.current</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { done: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> range) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(num); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1, 2, 3, 4, 5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>可迭代对象就是实现了 <code>Symbol.iterator</code> 方法的对象。</p><h2 id="用途" tabindex="-1">用途 <a class="header-anchor" href="#用途" aria-label="Permalink to &quot;用途&quot;">​</a></h2><ul><li><code>for...of</code></li><li>扩展 <code>...</code></li><li>解构 <code>{ xxx } = obj</code> <code>[xxx] = arr</code></li><li><code>yield*</code></li></ul><h2 id="可迭代对象-v-s-类数组对象" tabindex="-1">可迭代对象 v.s. 类数组对象 <a class="header-anchor" href="#可迭代对象-v-s-类数组对象" aria-label="Permalink to &quot;可迭代对象 v.s. 类数组对象&quot;">​</a></h2><p>两者没有必然联系，前者是迭代器模式的实现，后者是对数组的模拟，有 <code>length</code> 属性但是缺少相应的原型方法。</p><ul><li>可迭代对象 (Iterable)： <ul><li>实现了 <code>Symbol.iterator</code> 方法</li></ul></li><li>类数组对象 (Array-like)： <ul><li>有索引和 <code>length</code> 属性</li></ul></li></ul><p><code>Array.from()</code> 把可迭代对象或类数组对象转换为数组。</p>`,16),t=[n];function h(p,k,r,d,o,E){return a(),i("div",null,t)}const y=s(e,[["render",h]]);export{g as __pageData,y as default};
