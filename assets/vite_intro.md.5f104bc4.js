import{_ as i,c as l,o as t,a as e}from"./app.caf90d25.js";const o="/assets/bundle-based.fdb17e8b.png",s="/assets/native-esm-based.e1423ad8.png",S=JSON.parse('{"title":"Vite","description":"","frontmatter":{},"headers":[],"relativePath":"vite/intro.md"}'),r={name:"vite/intro.md"},a=e('<h1 id="vite" tabindex="-1">Vite <a class="header-anchor" href="#vite" aria-hidden="true">#</a></h1><p>背景：</p><ul><li>随着应用规模的增长，基于 JavaScript 开发的打包工具<strong>冷启动</strong>和<strong>热更新</strong>都很慢</li><li>浏览器开始原生支持 ES 模块</li><li>越来越多 JavaScript 工具使用编译型语言编写</li></ul><p>冷启动：</p><ul><li>将应用中的模块区分为<strong>依赖</strong>和<strong>源码</strong>两类</li><li>使用 esbuild 预构建第三方依赖，esbuild 使用 Go 编写，比 JS 打包器快 10-100 倍 <ul><li>原因： <ul><li>很多第三方库不提供 ESM 产物</li><li>一些第三方库模块数量多、依赖层级深，会触发过多网络请求</li></ul></li><li>过程： <ul><li>把第三方库尽可能打包，并转换为 ESM 格式</li><li>预构建产物缓存在 <code>node_modules/.vite</code> 目录下</li><li>重写源码中第三方库的引入路径</li></ul></li></ul></li><li>源码按需编译为 ESM 格式，Vite 在浏览器请求源码时进行转换并按需提供源码 <ul><li>让浏览器接管了打包程序的部分工作</li><li>根据情景动态导入代码，只在当前屏幕上实际使用时才会被处理</li></ul></li></ul><p><img src="'+o+'" alt=""><img src="'+s+'" alt=""></p><p>热更新：</p><ul><li>HMR 在原生 ESM 上执行，精确地使已编辑的模块与其<strong>最近的 HMR 边界</strong>之间的链失活 <ul><li>无论应用大小如何，HMR 始终能保持快速更新</li></ul></li><li>利用 HTTP 头来加速整个页面的重新加载 <ul><li>依赖模块的请求会通过 <code>Cache-Control: max-age=31536000,immutable</code> 进行<strong>强缓存</strong></li><li>源码模块的请求会根据 <code>304 Not Modified</code> 进行<strong>协商缓存</strong></li></ul></li></ul><p>生产环境：</p><ul><li>使用 Rollup 打包</li><li>嵌套导入会导致额外的网络往返，导致效率低下 (即使使用 HTTP/2)</li><li>为了获得最佳的加载性能，最好将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）</li></ul>',10),n=[a];function c(d,u,_,p,g,m){return t(),l("div",null,n)}const f=i(r,[["render",c]]);export{S as __pageData,f as default};
