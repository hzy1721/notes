import{_ as s}from"./chunks/class-extends.dcf01d74.js";import{_ as a,c as n,o as l,d as o}from"./app.e6616afd.js";const p="/assets/class-essence.2a578196.png",e="/assets/extends-native.75860f0e.png",g=JSON.parse('{"title":"class","description":"","frontmatter":{},"headers":[{"level":2,"title":"static","slug":"static","link":"#static","children":[]},{"level":2,"title":"extends","slug":"extends","link":"#extends","children":[]},{"level":2,"title":"私有属性和方法","slug":"私有属性和方法","link":"#私有属性和方法","children":[]},{"level":2,"title":"内建类型","slug":"内建类型","link":"#内建类型","children":[]}],"relativePath":"fe/js/class.md"}'),c={name:"fe/js/class.md"},t=o(`<h1 id="class" tabindex="-1">class <a class="header-anchor" href="#class" aria-hidden="true">#</a></h1><p><code>class</code> 是现代 JS 创建自定义类型的方式。</p><p>语法：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MyClass</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">prop1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> value1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">...</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop2</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">...</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop2</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">newVal</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">...</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">method1</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">...</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">...</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>然后可以使用 <code>new MyClass()</code> 创建对象，会调用 <code>constructor</code> 函数。</p><p>本质：</p><ul><li>创建一个名为 <code>MyClass</code> 的构造函数，参数和函数体来自 <code>constructor</code></li><li>在函数体内设置类属性，比如 <code>prop1</code></li><li>把访问器属性和方法设置在原型对象 <code>MyClass.prototype</code> 上，比如 <code>prop2</code>、<code>method1</code></li></ul><img src="`+p+`" width="70%"><p>与构造函数的区别：</p><ul><li>内部属性 <code>[[IsClassConstructor]]</code> 的值为 <code>true</code><ul><li>JS 会在很多地方用到这个属性，来区分 class 和构造函数 <ul><li>必须使用 <code>new</code> 调用，直接调用会报错</li><li><code>toString()</code> 的输出以 <code>class</code> 开头</li></ul></li></ul></li><li>位于原型上的方法不可枚举 <ul><li><code>enumerable: false</code></li></ul></li><li>总是使用 <code>use strict</code></li></ul><p>类似于函数，类声明也可以作为匿名或命名表达式，比如作为函数的参数和返回值。</p><p>如果把方法使用箭头函数声明为属性，可以避免丢失 <code>this</code> 的问题。但是这个方法将在每个对象上都有一份拷贝。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Button</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">value</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">click</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    alert(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="static" tabindex="-1">static <a class="header-anchor" href="#static" aria-hidden="true">#</a></h2><p>可以使用 <code>static</code> 声明静态属性和静态方法。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MyClass</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">staticProp</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">staticMethod</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">...</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 等价于</span></span>
<span class="line"><span style="color:#A6ACCD;">MyClass</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">staticProp </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">MyClass</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">staticMethod</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">...</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="extends" tabindex="-1">extends <a class="header-anchor" href="#extends" aria-hidden="true">#</a></h2><p><code>class</code> 使用 <code>extends</code> 让一个类继承另一个类。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Rabbit</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Animal</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>本质：</p><ul><li>把 <code>Rabbit.prototype.[[Prototype]]</code> 设置为 <code>Animal.prototype</code></li><li>把 <code>Rabbit.[[Prototype]]</code> 设置为 <code>Animal</code></li></ul><img src="`+s+`" width="70%"><ul><li>可以在子类 constructor 中使用 <code>super(...)</code> 调用父类 constructor</li><li>可以在子类方法中使用 <code>super.method(...)</code> 调用父类方法</li><li>箭头函数没有自己的 <code>super</code>，与声明时外部环境的 <code>super</code> 相同</li><li><code>super</code> 使用内部属性 <code>[[HomeObject]]</code> 实现，值为函数声明时所在的对象</li></ul><p>如果子类没有指定 constructor，会默认生成以下 constructor：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Rabbit</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Animal</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(...</span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">super</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">args</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>子类的 constructor <strong>必须</strong>调用父类的 constructor，并且在 <code>this</code> 的访问之前 <ul><li>为了实现父类实例属性的继承 (非原型属性)</li><li>使用 <code>new</code> 执行子类 constructor 时，不会创建空对象并赋值给 <code>this</code>，而是期望父类 constructor 完成这项工作</li></ul></li><li>子类属性会在父类 constructor 返回后开始初始化</li></ul><h2 id="私有属性和方法" tabindex="-1">私有属性和方法 <a class="header-anchor" href="#私有属性和方法" aria-hidden="true">#</a></h2><p>JS 没有在语言层面提供声明私有属性和方法的能力，可以用下划线 <code>_</code> 开头的名称表示这个属性或方法是私有的。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">CoffeeMachine</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">_waterAmount</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="内建类型" tabindex="-1">内建类型 <a class="header-anchor" href="#内建类型" aria-hidden="true">#</a></h2><ul><li>我们可以继承内建类型实现自己的类型，比如 <code>Array</code></li><li>内建类型之间不继承静态方法，只继承访问器属性和实例方法</li></ul><img src="`+e+'" width="70%">',32),r=[t];function i(y,D,F,C,d,A){return l(),n("div",null,r)}const m=a(c,[["render",i]]);export{g as __pageData,m as default};
