import{_ as s,c as e,o as l,a as o}from"./app.e3dff596.js";const a="/assets/cross-origin-proxy.95d05e9d.png",y=JSON.parse('{"title":"跨域","description":"","frontmatter":{},"headers":[{"level":2,"title":"浏览器的同源策略","slug":"浏览器的同源策略","link":"#浏览器的同源策略","children":[]},{"level":2,"title":"CORS","slug":"cors","link":"#cors","children":[{"level":3,"title":"CORS 的两种请求","slug":"cors-的两种请求","link":"#cors-的两种请求","children":[]}]},{"level":2,"title":"JSONP","slug":"jsonp","link":"#jsonp","children":[]},{"level":2,"title":"代理服务器","slug":"代理服务器","link":"#代理服务器","children":[]},{"level":2,"title":"WebSocket","slug":"websocket","link":"#websocket","children":[]}],"relativePath":"fe/browser/cross-origin.md"}'),n={name:"fe/browser/cross-origin.md"},c=o(`<h1 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-hidden="true">#</a></h1><h2 id="浏览器的同源策略" tabindex="-1">浏览器的同源策略 <a class="header-anchor" href="#浏览器的同源策略" aria-hidden="true">#</a></h2><p>跨域问题与浏览器的同源策略 (<strong>same-origin policy</strong>) 密切相关。</p><p>同源策略由 NetScape 于 1995 年引入浏览器，目前所有浏览器都实行这个策略。</p><p>目的是为了保证用户信息安全，防止恶意网站窃取用户数据 (比如 Cookie)。</p><p>同源指的是两个 URL 的协议 (<strong>protocol</strong>)、主机名 (<strong>host</strong>)、端口 (<strong>port</strong>) 都相同。</p><p>比如 <code>https://juejin.cn:443</code>：</p><ul><li>协议：https</li><li>主机名：<a href="http://juejin.cn" target="_blank" rel="noreferrer">juejin.cn</a> (此处是域名，也可以是 IP 地址)</li><li>端口：443 (HTTPS 端口，在浏览器中省略)</li></ul><p>当前页面请求一个不同源的 URL 则构成跨域，有很多场景可能用到跨域资源：</p><ul><li>AJAX 请求，比如 <code>XMLHttpRequest</code> 和 <code>Fetch</code></li><li><code>&lt;script&gt;</code> 引入 JavaScript 脚本、<code>&lt;link&gt;</code> 引入 CSS、<code>@font-face</code> 引入字体</li><li><code>&lt;img&gt;</code> 引入图片、<code>&lt;audio&gt;</code> 引入音频、<code>&lt;video&gt;</code> 引入视频</li><li><code>&lt;iframe&gt;</code> 引入外部页面</li></ul><p>跨域请求有 3 个限制：</p><ul><li>AJAX 无法请求非同源 URL</li><li>无法读取非同源 Cookie、localStorage、IndexedDB</li><li>无法读取非同源 DOM (<code>iframe</code> 或 <code>window.open</code>)</li></ul><p>实现跨域请求主要有 2 种方法：<code>JSONP</code> 和 <code>CORS</code>。</p><p>JSONP (JSON with Padding) 利用 <code>&lt;script&gt;</code> 允许跨域的特点实现从非同源 URL 获取 JSON 数据。优点是兼容性好，支持老式浏览器，不需要服务端支持 CORS，缺点是只支持 <code>GET</code> 请求。</p><p>CORS 支持全部 HTTP 请求，通信过程由浏览器完成、对用户透明、使用非常方便，只需要服务端做一些额外的配置，是目前主流的跨域解决方案。</p><h2 id="cors" tabindex="-1">CORS <a class="header-anchor" href="#cors" aria-hidden="true">#</a></h2><p><code>CORS</code> (Cross-Origin Resource Sharing，跨域资源共享) 是解决<strong>跨域问题</strong>最常用的方法 (另一种方法是 <code>JSONP</code>)，这篇文章主要阐述了使用 CORS 处理跨域的一些实现细节。</p><h3 id="cors-的两种请求" tabindex="-1">CORS 的两种请求 <a class="header-anchor" href="#cors-的两种请求" aria-hidden="true">#</a></h3><p>根据是否需要发送预检请求 (preflight) 可以将 CORS 请求分为 2 类：</p><ul><li>简单请求 (simple request)</li><li>非简单请求 (not-so-simple request)</li></ul><h4 id="简单请求" tabindex="-1">简单请求 <a class="header-anchor" href="#简单请求" aria-hidden="true">#</a></h4><p>满足以下 2 个条件的请求为简单请求：</p><ul><li>请求方法是以下 3 种方法之一： <ul><li><code>GET</code></li><li><code>HEAD</code></li><li><code>POST</code></li></ul></li><li>HTTP Header 只包含以下几种字段： <ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Last-Event-ID</code></li><li><code>Content-Type</code> (只支持以下 3 个值) <ul><li><code>application/x-www-form-urlencoded</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li></ul></li></ul></li></ul><p>对于简单请求，浏览器在 Request Header 中添加一个 <code>Origin</code> 字段，表明当前页面的 URL：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Origin: http://localhost:5173</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>如果服务端没有配置 CORS 或 <code>Origin</code> 的值不在允许的 URL 列表中，则会返回一个正常的 HTTP 响应，不包含额外的 Response Header。浏览器发现响应头没有 <code>Access-Control-Allow-Origin</code> 字段，说明这次跨域请求不被服务端支持，则抛出一个错误。</p><p>对于服务端支持的 <code>Origin</code>，响应头可能包含以下额外字段：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Access-Control-Allow-Origin: http://localhost:5173</span></span>
<span class="line"><span style="color:#A6ACCD;">Access-Control-Allow-Credentials: true</span></span>
<span class="line"><span style="color:#A6ACCD;">Access-Control-Expose-Headers: FooBar</span></span>
<span class="line"><span style="color:#A6ACCD;">Content-Type: text/html; charset=utf-8</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li><code>Access-Control-Allow-Origin</code>：服务端允许请求的 URL，取值为 <code>Origin</code> 的值或一个星号 <code>*</code>，表示允许所有 URL</li><li><code>Access-Control-Allow-Credentials</code>：CORS 请求默认不发送 Cookie，设为 <code>true</code> 表示服务端允许发送 Cookie，<strong>不能</strong>设为 <code>false</code>，如果不允许 Cookie，不包含这个字段即可</li><li><code>Access-Control-Expose-Headers</code>：可选字段，CORS 请求默认只能拿到响应头的 6 个基本字段，可以在此处指定允许访问的其他字段 <ul><li><code>Cache-Control</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code></li><li><code>Expires</code></li><li><code>Last-Modified</code></li><li><code>Pragma</code></li></ul></li></ul><h5 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-hidden="true">#</a></h5><p>如果要通过 CORS 请求发送 Cookie，除了需要服务端设置 <code>Access-Control-Allow-Credentials</code> 为 <code>true</code> 以及 <code>Access-Control-Allow-Origin</code> 不能为 <code>*</code>，还需要在 AJAX 中设置：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> xhr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">XMLHttpRequest</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">xhr</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">withCredentials </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 发送 Cookie</span></span>
<span class="line"><span style="color:#A6ACCD;">xhr</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">withCredentials </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 禁止 Cookie</span></span>
<span class="line"></span></code></pre></div><h4 id="非简单请求" tabindex="-1">非简单请求 <a class="header-anchor" href="#非简单请求" aria-hidden="true">#</a></h4><p>不属于简单请求的为非简单请求，通常是 <code>PUT</code>、<code>DELETE</code> 方法或 <code>Content-Type</code> 为 <code>application/json</code>。</p><h5 id="预检请求-preflight" tabindex="-1">预检请求 (preflight) <a class="header-anchor" href="#预检请求-preflight" aria-hidden="true">#</a></h5><p>在正式请求之前的一次额外请求，使用 <code>OPTIONS</code> 方法询问服务端当前 URL 是否被允许、允许的 Method 和 Header。请求头包含以下的额外字段：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Origin: http://localhost:5173</span></span>
<span class="line"><span style="color:#A6ACCD;">Access-Control-Request-Method: PUT</span></span>
<span class="line"><span style="color:#A6ACCD;">Access-Control-Request-Headers: X-Custom-Header</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li><code>Access-Control-Request-Method</code>：非简单请求的方法</li><li><code>Access-Control-Request-Headers</code>：可能发送的额外字段</li></ul><p>如果服务端允许这三条要求，则发回一条有额外响应头的报文：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Access-Control-Allow-Origin: http://localhost:5173</span></span>
<span class="line"><span style="color:#A6ACCD;">Access-Control-Allow-Methods: GET, POST, PUT</span></span>
<span class="line"><span style="color:#A6ACCD;">Access-Control-Allow-Headers: X-Custom-Header</span></span>
<span class="line"><span style="color:#A6ACCD;">Access-Control-Allow-Credentials: true</span></span>
<span class="line"><span style="color:#A6ACCD;">Access-Control-Max-Age: 1728000</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li><code>Access-Control-Allow-Methods</code>：服务端允许的所有方法，不限于 <code>Access-Control-Request-Method</code> 中的方法</li><li><code>Access-Control-Allow-Headers</code>：服务端允许的所有 Header，不限于 <code>Access-Control-Allow-Headers</code> 中的 Header</li><li><code>Access-Control-Max-Age</code>：本次预检请求的有效期，以秒为单位</li></ul><p>如果服务端不支持这次跨域请求，则返回不包含以上额外 Header 的响应。</p><h5 id="正式通信" tabindex="-1">正式通信 <a class="header-anchor" href="#正式通信" aria-hidden="true">#</a></h5><p>通过预检请求后，后续的 CORS 请求与简单请求的交互过程相同，Request Header 会包含 <code>Origin</code>，Response Header 会包含 <code>Access-Control-Allow-Origin</code>。</p><h2 id="jsonp" tabindex="-1">JSONP <a class="header-anchor" href="#jsonp" aria-hidden="true">#</a></h2><p>拥有 <code>src</code> 属性的标签不受浏览器同源策略的影响，可以请求跨域资源。</p><ul><li><code>&lt;script&gt;</code></li><li><code>&lt;img&gt;</code></li><li><code>&lt;iframe&gt;</code></li></ul><p>JSONP 的工作流程如下：</p><ol><li>声明一个回调函数，参数是将要请求的数据，函数内可以对数据进行后续的处理。</li><li>构造 <code>&lt;script&gt;</code> 元素，将 <code>src</code> 属性设为接口地址，并带上回调函数名的 query param。</li><li><code>&lt;script&gt;</code> 元素加入 DOM，自动请求接口，返回的 JS 脚本会包含对回调函数的调用，传入的参数就是希望从后端获取的数据。</li><li>JS 脚本自动执行，回调函数以请求数据为参数被执行。</li></ol><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">userCallback</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">userData</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">User data received: </span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">userData</span><span style="color:#89DDFF;">}\`</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">http://api.example.com/users/123?callback=userCallback</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#82AAFF;">userCallback</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">id</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">123</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Test User</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">email</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">test@example.com</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><h2 id="代理服务器" tabindex="-1">代理服务器 <a class="header-anchor" href="#代理服务器" aria-hidden="true">#</a></h2><p>配置与前端<strong>同源</strong>的代理服务器，负责转发请求和响应。</p><p><img src="`+a+'" alt=""></p><p>原理是代理服务器和后端之间不存在跨域问题 (跨域只存在于<strong>浏览器</strong>)。</p><h2 id="websocket" tabindex="-1">WebSocket <a class="header-anchor" href="#websocket" aria-hidden="true">#</a></h2><p>WebSocket 协议不执行同源策略，允许跨域。但是一般不会为了跨域就把 HTTP 请求换成 WebSocket 通信。</p>',57),t=[c];function p(r,i,d,C,A,D){return l(),e("div",null,t)}const u=s(n,[["render",p]]);export{y as __pageData,u as default};
