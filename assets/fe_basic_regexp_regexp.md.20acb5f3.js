import{_ as d,c as e,o as t,U as o}from"./chunks/framework.e548c890.js";const _=JSON.parse('{"title":"RegExp","description":"","frontmatter":{},"headers":[],"relativePath":"fe/basic/regexp/regexp.md","filePath":"fe/basic/regexp/regexp.md","lastUpdated":1697294017000}'),c={name:"fe/basic/regexp/regexp.md"},l=o('<h1 id="regexp" tabindex="-1">RegExp <a class="header-anchor" href="#regexp" aria-label="Permalink to &quot;RegExp&quot;">​</a></h1><p>正则表达式由模式 (pattern) 和修饰符 (flag) 组成。</p><p>创建正则表达式：</p><ul><li>字面量：<code>/pattern/flags</code><ul><li>需要转义正斜杠，不需要转义反斜杠</li><li>不支持变量插值，无法组合已有的正则表达式</li></ul></li><li>RegExp 构造函数：<code>new RegExp(&#39;pattern&#39;, &#39;flags&#39;)</code><ul><li>pattern 字符串需要转义反斜杠，不需要转义正斜杠</li><li>允许将多个正则字符串组合为更长的正则表达式</li></ul></li></ul><h2 id="模式" tabindex="-1">模式 <a class="header-anchor" href="#模式" aria-label="Permalink to &quot;模式&quot;">​</a></h2><ul><li><code>^</code> 匹配开头，<code>$</code> 匹配结尾 <ul><li>使用修饰符 <code>m</code> 后匹配每一行的开头和结尾</li></ul></li><li><code>\\b</code> 匹配词边界，也就是一侧有 <code>\\w</code>、另一侧没有 <code>\\w</code></li><li>字符类表示特定类别的一个字符</li></ul><table><thead><tr><th>字符类</th><th>含义</th></tr></thead><tbody><tr><td><code>\\d</code> (digit)</td><td>数字</td></tr><tr><td><code>\\s</code> (space)</td><td>空白符：空格、<code>\\t</code>、<code>\\n</code>、<code>\\v</code>、<code>\\f</code>、<code>\\r</code> 等</td></tr><tr><td><code>\\w</code> (word)</td><td>“单字”：字母、数字、下划线 <code>_</code></td></tr><tr><td><code>\\D</code></td><td><code>\\d</code> 反向类，非数字</td></tr><tr><td><code>\\S</code></td><td><code>\\S</code> 反向类，非空白符</td></tr><tr><td><code>\\W</code></td><td><code>\\w</code> 反向类，非字母、数字、下划线</td></tr><tr><td><code>.</code></td><td>除 <code>\\n</code> 外任何字符</td></tr></tbody></table><ul><li>集合 <code>[xxx]</code> 表示方括号中字符中的任意一个 <ul><li>集合可以包含范围，比如 <code>[a-z]</code>、<code>[A-Z]</code>、<code>[0-9]</code></li><li>集合开头加上 <code>^</code> 表示除方括号中字符之外的任意字符</li><li>除了集合中有特殊含义的字符，其他特殊字符都不需要转义</li><li>需要转义的字符： <ul><li>开头的 <code>^</code></li><li>中间的 <code>-</code></li><li>右方括号 <code>]</code></li></ul></li></ul></li><li><code>|</code> 表示或</li><li>捕获组 (capturing group) 是用圆括号 <code>()</code> 括起来的部分 <ul><li>没有 <code>g</code> 修饰符的匹配结果数组会包含每个组的匹配结果，按照从左到右、从外到内的顺序编号</li><li>左括号后紧跟 <code>?&lt;name&gt;</code> 为组命名，通过 <code>res.groups.name</code> 访问</li><li>如果必须使用捕获组但不希望出现在匹配结果里，在开头添加 <code>?:</code></li><li>在正则中使用 <code>\\N</code> 和 <code>\\k&lt;name&gt;</code> 引用前面出现的组</li></ul></li><li>量词表示匹配的字符数量 <ul><li>确切数量：<code>{n}</code></li><li>数量范围：<code>{lo, hi}</code> 闭区间，<code>hi</code> 省略表示无限</li><li>简写： <ul><li><code>?</code>：<code>{0,1}</code></li><li><code>*</code>：<code>{0,}</code></li><li><code>+</code>：<code>{1,}</code></li></ul></li><li>量词匹配默认是贪婪的 (greedy)，尽可能多地匹配字符，直到不满足条件再回溯</li><li>在量词后添加问号 <code>?</code> 启用惰性量词 (lazy) <ul><li>比如 <code>??</code>、<code>*?</code>、<code>+?</code></li><li>尽可能少地匹配字符，每次匹配成功后就停下来尝试匹配剩余部分</li></ul></li></ul></li><li>前瞻断言 lookahead (看右边) <ul><li><code>X(?=Y)</code>：仅在后面是 <code>Y</code> 时匹配 <code>X</code></li><li><code>X(?!Y)</code>：仅在后面不是 <code>Y</code> 时匹配 <code>X</code></li></ul></li><li>后瞻断言 lookbehind (看左边) <ul><li><code>(?&lt;=Y)X</code>：仅在前面是 <code>Y</code> 时匹配 <code>X</code></li><li><code>(?&lt;!Y)X</code>：仅在前面不是 <code>Y</code> 时匹配 <code>X</code></li></ul></li><li>转义 <ul><li>特殊字符 <code>[ ] { } ( ) \\ ^ $ . | ? * +</code> 使用反斜杠 <code>\\</code> 进行转义</li><li>正则字面量需要转义 <code>/</code>，普通字符串需要转义 <code>\\</code></li></ul></li><li><code>\\p{}</code> 和修饰符 <code>u</code> 匹配 Unicode 字符</li></ul><table><thead><tr><th>正则</th><th>全称</th><th>含义</th></tr></thead><tbody><tr><td><code>L</code></td><td>Letter</td><td>字母</td></tr><tr><td><code>Ll</code></td><td>lowercase</td><td>小写</td></tr><tr><td><code>Lm</code></td><td>modifier</td><td>修饰</td></tr><tr><td><code>Lt</code></td><td>titlecase</td><td>首字母大写</td></tr><tr><td><code>Lu</code></td><td>uppercase</td><td>大写</td></tr><tr><td><code>Lo</code></td><td>other</td><td>其他</td></tr></tbody></table><h2 id="修饰符" tabindex="-1">修饰符 <a class="header-anchor" href="#修饰符" aria-label="Permalink to &quot;修饰符&quot;">​</a></h2><table><thead><tr><th>修饰符</th><th>全称</th><th>含义</th></tr></thead><tbody><tr><td>i</td><td>ignore</td><td>不区分大小写</td></tr><tr><td>g</td><td>global</td><td>搜索所有匹配项</td></tr><tr><td>m</td><td>multi-line</td><td>多行模式</td></tr><tr><td>s</td><td></td><td>允许 <code>.</code> 匹配 <code>\\n</code></td></tr><tr><td>u</td><td>unicode</td><td>完整 Unicode 支持</td></tr><tr><td>y</td><td></td><td>在指定位置搜索</td></tr></tbody></table>',11),i=[l];function r(a,u,h,n,p,s){return t(),e("div",null,i)}const b=d(c,[["render",r]]);export{_ as __pageData,b as default};
