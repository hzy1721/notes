import{_ as s,c as i,o as a,a1 as e}from"./chunks/framework.mNpZ2GHZ.js";const g=JSON.parse('{"title":"构造函数","description":"","frontmatter":{},"headers":[],"relativePath":"fe/lang/js/constructor.md","filePath":"fe/lang/js/constructor.md","lastUpdated":1702822707000}'),n={name:"fe/lang/js/constructor.md"},t=e(`<h1 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-label="Permalink to &quot;构造函数&quot;">​</a></h1><p>类和对象是 OOP 的核心概念，类是相同类型对象的抽象，类封装对象创建的代码，实现代码复用。JavaScript 通过构造函数和 <code>new</code> 操作符实现相同类型对象的创建。</p><p>比如，可以使用 <code>new Object()</code> 创建一个空对象，其中 <code>new</code> 是一种操作符、<code>Object</code> 是一个构造函数。除了 <code>Object</code>，JS 还提供了 <code>Array</code>、<code>Set</code>、<code>Map</code> 等内置构造函数。开发者也可以自定义构造函数，相当于创建一个新的类型，从而避免重复书写字面量。</p><h2 id="构造函数-1" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数-1" aria-label="Permalink to &quot;构造函数&quot;">​</a></h2><p>构造函数是用于创建同一类型对象的函数，有以下 2 个约定：</p><ul><li>首字母大写，表示这是一种类型</li><li>只能通过 <code>new</code> 操作符执行</li></ul><p>函数体内访问到的 <code>this</code> 表示正在创建的对象，可以在函数体内为对象设置属性。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.isAdmin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="new-操作符" tabindex="-1">new 操作符 <a class="header-anchor" href="#new-操作符" aria-label="Permalink to &quot;new 操作符&quot;">​</a></h2><p>使用 <code>new</code> 操作符执行一个构造函数 <code>F</code> 时，执行以下操作：</p><ul><li>创建一个空对象并分配给 <code>this</code></li><li>如果 <code>F.prototype</code> 是一个对象，则把空对象的原型设置为 <code>F.prototype</code></li><li>执行构造函数的函数体</li><li>根据函数体内是否有返回语句以及返回值的类型，确定最终的返回值，默认返回 <code>this</code> 的值</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Jack&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// { name: &quot;Jack&quot;, isAdmin: false }</span></span></code></pre></div><p>构造函数的本质就是一个普通函数，结合 <code>new</code> 操作符的功能实现同一类型对象的创建。<code>new</code> 操作可以应用于任何函数 (除箭头函数)，都会执行以上的步骤。</p><h2 id="return" tabindex="-1">return <a class="header-anchor" href="#return" aria-label="Permalink to &quot;return&quot;">​</a></h2><p>如果构造函数提供了 <code>return</code> 语句：</p><ul><li>返回的是 <code>Object</code>：返回该对象，而不是 <code>this</code></li><li>返回的是原始类型：忽略该 <code>return</code> 语句，依旧返回 <code>this</code></li></ul><p>通常不提供 <code>return</code> 语句，而是返回 <code>this</code>。</p><h2 id="new-target" tabindex="-1">new.target <a class="header-anchor" href="#new-target" aria-label="Permalink to &quot;new.target&quot;">​</a></h2><p>部分构造函数既可以结合 <code>new</code> 操作符执行，也可以直接调用，比如 <code>Date</code>。<code>new Date()</code> 返回当前时间的 <code>Date</code> 对象，而 <code>Date()</code> 返回当前时间的字符串表示，等价于 <code>new Date().toString()</code>。</p><p>使用 <code>new.target</code> 可以区分使用 <code>new</code> 调用和直接调用：</p><ul><li><code>new</code> 调用：当前构造函数</li><li>直接调用：<code>undefined</code></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// undefined</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// User</span></span></code></pre></div><p>让构造函数以两种方式都能使用有以下优缺点：</p><ul><li>构造函数的使用更加灵活，提供更多功能，程序不容易报错</li><li>忽略 <code>new</code> 不那么直观，降低代码可读性</li><li>缺少 <code>new</code> 的编程错误更不容易被发现，导致不符合预期的程序行为</li></ul><p>通常只允许构造函数以 <code>new</code> 的方式使用，很少允许直接调用。</p><h2 id="class" tabindex="-1">class <a class="header-anchor" href="#class" aria-label="Permalink to &quot;class&quot;">​</a></h2><p>尽管 <code>new</code> 和构造函数<strong>创建对象</strong>的语法足够直观、与其他语言类似，但是<strong>声明类</strong>使用的构造函数与其他 OOP 语言差别较大，增加了学习成本。ES6 引入了类的概念和 <code>class</code> 语法，使类的定义更加清晰易读、更接近于传统 OOP 的声明方式。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;(&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;, &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>class</code> 声明的类型同样使用 <code>new</code> 来创建实例。<code>class</code> 可以看作构造函数的语法糖，<code>class</code> 能够实现的绝大部分功能，使用构造函数也能实现。</p>`,29),l=[t];function h(p,k,d,c,o,r){return a(),i("div",null,l)}const y=s(n,[["render",h]]);export{g as __pageData,y as default};
