import{_ as i,c as s,o as a,a1 as l}from"./chunks/framework.mNpZ2GHZ.js";const t="/assets/juejin.DJ8Fksz3.png",e="/assets/cross-origin-proxy.C8r-22CS.png",y=JSON.parse('{"title":"跨域","description":"","frontmatter":{},"headers":[],"relativePath":"fe/security/policy/cross-origin.md","filePath":"fe/security/policy/cross-origin.md","lastUpdated":1697294017000}'),n={name:"fe/security/policy/cross-origin.md"},p=l('<h1 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-label="Permalink to &quot;跨域&quot;">​</a></h1><p>跨域问题 (cross origin) 来源于浏览器的同源策略 (same-origin policy)。</p><h2 id="浏览器的同源策略" tabindex="-1">浏览器的同源策略 <a class="header-anchor" href="#浏览器的同源策略" aria-label="Permalink to &quot;浏览器的同源策略&quot;">​</a></h2><p>同源策略由 NetScape 于 1995 年引入浏览器，目的是为了保证用户信息安全，防止恶意网站窃取用户数据 (比如 Cookie)。目前所有浏览器都实行这个策略。</p><p>同源：两个 URL 的协议 (<strong>protocol</strong>)、主机名 (<strong>host</strong>)、端口 (<strong>port</strong>) 都相同。</p><p><img src="'+t+`" alt=""></p><p>请求与当前页面不同源的 URL 即为跨域。</p><p>常见的跨域请求：</p><ul><li>AJAX 请求，比如 <code>XMLHttpRequest</code> 和 <code>Fetch</code></li></ul><p>原生支持跨域：</p><ul><li><code>@font-face</code> 引入字体</li><li><code>&lt;link&gt;</code> 引入 CSS</li><li><code>&lt;script&gt;</code> 引入 JavaScript 脚本</li><li><code>&lt;img&gt;</code> 引入图片</li><li><code>&lt;audio&gt;</code> 引入音频、<code>&lt;video&gt;</code> 引入视频</li><li><code>&lt;iframe&gt;</code> 引入外部页面</li><li><code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code> 引入外部资源</li></ul><p>同源策略对跨域请求做了以下限制：</p><ul><li>AJAX 无法请求非同源 URL</li><li>无法读取非同源 Cookie、localStorage、IndexedDB</li><li>无法读取非同源 DOM (<code>iframe</code> 或 <code>window.open</code>)</li></ul><h2 id="cors" tabindex="-1">CORS <a class="header-anchor" href="#cors" aria-label="Permalink to &quot;CORS&quot;">​</a></h2><p>CORS 在服务端做配置，返回 <code>Access-Control-*</code> 响应头。</p><ul><li>优点： <ul><li>支持全部 HTTP 请求</li><li>通信过程由浏览器完成、对用户透明、使用方便</li></ul></li><li>缺点： <ul><li>服务端需要做额外配置</li></ul></li></ul><p><a href="./cors.html">CORS</a></p><h2 id="jsonp" tabindex="-1">JSONP <a class="header-anchor" href="#jsonp" aria-label="Permalink to &quot;JSONP&quot;">​</a></h2><p>JSONP (JSON with Padding) 利用 <code>&lt;script&gt;</code> 允许跨域的特点实现从非同源 URL 获取 JSON 数据。</p><ul><li>优点： <ul><li>兼容性好，支持老式浏览器</li><li>不需要服务端做配置</li></ul></li><li>缺点： <ul><li>只支持 <code>GET</code> 请求</li></ul></li></ul><p>原理：拥有 <code>src</code> 属性的标签不受浏览器同源策略的影响，可以请求跨域资源。</p><ul><li><code>&lt;script&gt;</code></li><li><code>&lt;img&gt;</code></li><li><code>&lt;iframe&gt;</code></li></ul><p>JSONP 的工作流程如下：</p><ol><li>声明一个回调函数，参数是将要请求的数据，函数内可以对数据进行后续的处理。</li><li>构造 <code>&lt;script&gt;</code> 元素，将 <code>src</code> 属性设为接口地址，并带上回调函数名的 query param。</li><li><code>&lt;script&gt;</code> 元素加入 DOM，自动请求接口，返回的 JS 脚本会包含对回调函数的调用，传入的参数就是希望从后端获取的数据。</li><li>JS 脚本自动执行，回调函数以请求数据为参数被执行。</li></ol><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> userCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">userData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`User data received: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">userData</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://api.example.com/users/123?callback=userCallback&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">userCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;123&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Test User&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  email: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;test@example.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="代理服务器" tabindex="-1">代理服务器 <a class="header-anchor" href="#代理服务器" aria-label="Permalink to &quot;代理服务器&quot;">​</a></h2><p>原理：同源策略是浏览器提出的，Node 没有同源策略。(跨域只存在于浏览器)</p><p>配置与前端同源的代理服务器，负责转发请求和响应，代理服务器和后端不需要同源。</p><p><img src="`+e+'" alt=""></p><h2 id="websocket" tabindex="-1">WebSocket <a class="header-anchor" href="#websocket" aria-label="Permalink to &quot;WebSocket&quot;">​</a></h2><p>原理：WebSocket 不执行同源策略，允许跨域。</p><p>但是一般不会为了跨域就把 HTTP 请求换成 WebSocket 通信。</p>',33),o=[p];function h(c,r,d,k,E,g){return a(),s("div",null,o)}const m=i(n,[["render",h]]);export{y as __pageData,m as default};
