import{_ as e,c as l,o as a,U as i}from"./chunks/framework.e548c890.js";const f=JSON.parse('{"title":"内存泄漏","description":"","frontmatter":{},"headers":[],"relativePath":"fe/perf/issue/memory-leak.md","filePath":"fe/perf/issue/memory-leak.md","lastUpdated":1702821351000}'),o={name:"fe/perf/issue/memory-leak.md"},t=i('<h1 id="内存泄漏" tabindex="-1">内存泄漏 <a class="header-anchor" href="#内存泄漏" aria-label="Permalink to &quot;内存泄漏&quot;">​</a></h1><p>本质：保持引用不再使用的对象，导致无用对象无法回收，内存持续被占用。</p><h2 id="可能原因" tabindex="-1">可能原因 <a class="header-anchor" href="#可能原因" aria-label="Permalink to &quot;可能原因&quot;">​</a></h2><ol><li>全局变量 (永远不会被回收，谨慎使用)</li><li>闭包引用的外部变量</li><li>定时器用完没有清除 (<code>clearTimeout</code>)</li><li>元素从 DOM 移除，但还有变量引用</li><li><code>console.log</code> (不打开控制台没事)</li></ol><h2 id="排查流程" tabindex="-1">排查流程 <a class="header-anchor" href="#排查流程" aria-label="Permalink to &quot;排查流程&quot;">​</a></h2><p>代码角度：</p><ol><li>打开 Performance，手动 GC 一次，勾选 Memory，开始录制</li><li>做一些操作，触发内存增长，再手动 GC 一次</li><li>定位无法被 GC 的内存分配时间点，点击火焰图中的任务查看对应代码</li><li>分析可能的问题并修改</li></ol><p>内存角度：</p><ol><li>打开 Memory，手动 GC 一次，录制一次堆快照</li><li>做一些操作，触发内存增长，再手动 GC 一次</li><li>再录制一次堆快照，对比前后两次快照，找到增长最多的对象</li><li>分析可能的问题并修改</li><li>也可以实时记录内存分配，定位内存增长后没有被 GC 的部分</li></ol>',9),r=[t];function s(c,n,d,_,m,h){return a(),l("div",null,r)}const u=e(o,[["render",s]]);export{f as __pageData,u as default};
