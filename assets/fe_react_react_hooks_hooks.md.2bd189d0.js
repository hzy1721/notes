import{_ as o,c as e,o as l,U as t}from"./chunks/framework.e548c890.js";const _=JSON.parse('{"title":"hooks","description":"","frontmatter":{},"headers":[],"relativePath":"fe/react/react/hooks/hooks.md","filePath":"fe/react/react/hooks/hooks.md","lastUpdated":1702821351000}'),i={name:"fe/react/react/hooks/hooks.md"},c=t('<h1 id="hooks" tabindex="-1">hooks <a class="header-anchor" href="#hooks" aria-label="Permalink to &quot;hooks&quot;">​</a></h1><p>React 16.8 引入，提供一系列 <code>use</code> 开头的函数，支持在函数组件内保存状态和触发副作用。</p><p>函数组件 + hooks 的写法解决了类组件的一些缺点，逐渐成为 React 的主流写法。</p><p>React 内置一些常用 hook，包括 <code>useState</code>、<code>useEffect</code>、<code>useContext</code> 等。</p><p>开发者也可以基于内置 hook 编写自定义 hook，提取组件的状态和逻辑。</p><h2 id="限制" tabindex="-1">限制 <a class="header-anchor" href="#限制" aria-label="Permalink to &quot;限制&quot;">​</a></h2><ul><li>只在<strong>最顶层</strong>使用 hook，确保每次渲染以相同的顺序调用 hook <ul><li>函数组件或自定义 hook 的顶层作用域</li><li>不能在条件判断、循环体、嵌套函数内调用 hook</li></ul></li><li>只在<strong>函数组件</strong>和<strong>自定义 hook</strong> 中调用 Hook，不在普通函数中使用 hook <ul><li>确保组件的状态逻辑清晰可读</li></ul></li></ul><h2 id="内置-hook" tabindex="-1">内置 hook <a class="header-anchor" href="#内置-hook" aria-label="Permalink to &quot;内置 hook&quot;">​</a></h2><ul><li>状态 hook <ul><li><code>useState</code>：单个状态</li><li><code>useReducer</code>：复杂状态的管理，比如对象、数组</li></ul></li><li>context hook <ul><li><code>useContext</code>：读取 context 数据</li></ul></li><li>ref hook <ul><li><code>useRef</code>：记忆数据，修改不会触发重新渲染，通常用于引用 DOM 节点</li><li><code>useImperativeHandle</code>：自定义组件暴露的 ref</li></ul></li><li>effect hook <ul><li><code>useEffect</code>：与外界系统同步</li><li><code>useLayoutEffect</code>：浏览器重绘之前触发，可用于测量布局</li><li><code>useInsertionEffect</code>：React 更新 DOM 之前触发，可用于插入动态 CSS</li></ul></li><li>性能 hook <ul><li><code>useMemo</code>：缓存昂贵计算</li><li><code>useCallback</code>：缓存函数定义</li><li><code>useTransition</code>：标记状态更新可以被中断</li><li><code>useDeferredValue</code>：推迟耗时的状态更新，优先更新其他状态</li></ul></li><li>其他 hook <ul><li><code>useDebugValue</code>：自定义 hook 在 React DevTools 里的标签</li><li><code>useId</code>：给组件分配一个唯一 ID，通常用于 a11y</li><li><code>useSyncExternalStore</code>：订阅外部数据源</li></ul></li></ul><h2 id="自定义-hook" tabindex="-1">自定义 hook <a class="header-anchor" href="#自定义-hook" aria-label="Permalink to &quot;自定义 hook&quot;">​</a></h2><p>通过组合其他 hook 编写面向更具体功能的 hook，实现状态、逻辑的封装和复用。</p><ul><li>与内置 hook 相同，自定义 hook 的名称必须以 <code>use</code> 开头，遵循驼峰命名法</li><li>与组件包括 state、effect、event handler、JSX 不同，自定义 hook 只包括 state、effect</li><li>一个 hook 的返回值可能成为另一个 hook 的参数</li><li>每次编写 effect 时，可以考虑是否封装为一个自定义 hook</li><li>未来 React 可能会提供新的 API 代替部分 effect，到时候就只需要修改自定义 hook，而不是所有用到该 effect 的组件</li></ul>',12),a=[c];function s(h,d,r,u,k,n){return l(),e("div",null,a)}const p=o(i,[["render",s]]);export{_ as __pageData,p as default};
