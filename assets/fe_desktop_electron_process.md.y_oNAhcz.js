import{_ as s,c as i,o as a,a1 as e}from"./chunks/framework.mNpZ2GHZ.js";const n="/assets/main_renderer.Ckgm9_i4.awebp",l="/assets/main_renderer_api.HXmKPlvx.awebp",F=JSON.parse('{"title":"进程模型","description":"","frontmatter":{},"headers":[],"relativePath":"fe/desktop/electron/process.md","filePath":"fe/desktop/electron/process.md","lastUpdated":1720354129000}'),t={name:"fe/desktop/electron/process.md"},p=e('<h1 id="进程模型" tabindex="-1">进程模型 <a class="header-anchor" href="#进程模型" aria-label="Permalink to &quot;进程模型&quot;">​</a></h1><p>Electron 基于 Chromium 构建，也采用了类似的多进程架构。</p><p>单进程优缺点：</p><ul><li>尽可能资源共享，额外开销小</li><li>隔离性差，一个页面崩溃会影响整个浏览器</li></ul><p>Electron 进程分为 main 和 renderer 两类。</p><p><img src="'+n+'" alt=""></p><h2 id="主进程-main" tabindex="-1">主进程 main <a class="header-anchor" href="#主进程-main" aria-label="Permalink to &quot;主进程 main&quot;">​</a></h2><p>每个 Electron 应用只有 1 个主进程，是应用的入口，运行在 Node 环境。</p><p>负责：</p><ul><li>管理窗口 <code>BrowserWindow</code></li><li>管理渲染进程和页面 <code>webContents</code></li><li>管理生命周期 <code>app</code></li><li>提供原生 API <ul><li>菜单/对话框</li><li>授权操作</li></ul></li></ul><p>不能：</p><ul><li>访问和操作 DOM</li></ul><p><img src="'+l+`" alt=""></p><h2 id="渲染进程-renderer" tabindex="-1">渲染进程 renderer <a class="header-anchor" href="#渲染进程-renderer" aria-label="Permalink to &quot;渲染进程 renderer&quot;">​</a></h2><p>每个打开的窗口对应一个渲染进程，运行在 Chromium 环境。</p><p>负责：</p><ul><li>管理前端页面</li></ul><p>不能：</p><ul><li>访问 Node 环境和原生 API</li></ul><h3 id="preload-脚本" tabindex="-1">preload 脚本 <a class="header-anchor" href="#preload-脚本" aria-label="Permalink to &quot;preload 脚本&quot;">​</a></h3><p>在渲染进程中、页面加载之前执行，允许访问部分 Node API。</p><p>在主脚本中附加到窗口上：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> win</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BrowserWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  webPreferences: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    preload: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;path/to/preload.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="contextisolation" tabindex="-1">contextIsolation <a class="header-anchor" href="#contextisolation" aria-label="Permalink to &quot;contextIsolation&quot;">​</a></h3><p>出于安全原因，preload 脚本与页面是隔离的，二者访问的 <code>window</code> 不是同一个。</p><p>需要使用 <code>contextBridge</code> 进行变量的传递，相比直接设置 <code>window</code> 有更多限制、更加安全。</p><p>尽管 <code>contextBridge</code> 提供了安全方面的限制，但开发者还需要尽可能收缩权限，避免直接传递功能强大的 IPC 函数。</p><h3 id="contextbridge" tabindex="-1">contextBridge <a class="header-anchor" href="#contextbridge" aria-label="Permalink to &quot;contextBridge&quot;">​</a></h3><p>设置页面的全局变量：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// preload.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">contextBridge.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exposeInMainWorld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myAPI&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  desktop: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// renderer.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window.myAPI);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; { desktop: true }</span></span></code></pre></div><h3 id="ts-支持" tabindex="-1">TS 支持 <a class="header-anchor" href="#ts-支持" aria-label="Permalink to &quot;TS 支持&quot;">​</a></h3><p>通过 <code>contextBridge</code> 传递的属性需要手动添加类型定义。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// preload.ts</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">contextBridge.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exposeInMainWorld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;electronAPI&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  loadPreferences</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ipcRenderer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;load-prefs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// renderer.d.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IElectronAPI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  loadPreferences</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> global {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    electronAPI</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IElectronAPI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="创建子进程" tabindex="-1">创建子进程 <a class="header-anchor" href="#创建子进程" aria-label="Permalink to &quot;创建子进程&quot;">​</a></h2><ul><li>Electron 提供了 <code>utilityProcess</code> 用于创建子进程</li><li>相比 Node 原生的 <code>child_process.fork</code>，能够更方便地与渲染进程通信 (通过 <code>MessagePort</code>)</li><li>因此在 Electron 应用中创建子进程时优先使用 <code>utilityProcess</code></li></ul><h2 id="类型优化" tabindex="-1">类型优化 <a class="header-anchor" href="#类型优化" aria-label="Permalink to &quot;类型优化&quot;">​</a></h2><p>Electron 包的子路径提供了更完善的类型定义。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;electron/main&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">shell</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;electron/common&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div>`,38),h=[p];function k(r,d,o,E,c,g){return a(),i("div",null,h)}const u=s(t,[["render",k]]);export{F as __pageData,u as default};
