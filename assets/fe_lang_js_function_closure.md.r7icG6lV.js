import{_ as s,c as i,o as a,a1 as n}from"./chunks/framework.mNpZ2GHZ.js";const l="/assets/closure_variable.D6dpNUOy.png",t="/assets/closure_function.D0ec6B13.png",p="/assets/closure_outer.8YLgw4l8.png",F=JSON.parse('{"title":"闭包","description":"","frontmatter":{},"headers":[],"relativePath":"fe/lang/js/function/closure.md","filePath":"fe/lang/js/function/closure.md","lastUpdated":1702822707000}'),e={name:"fe/lang/js/function/closure.md"},h=n('<h1 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h1><p>闭包 (closure) 是指函数声明时会绑定外部环境，无论传递到哪里调用，函数内都能访问到<strong>声明时</strong>的外部变量 (外部环境)。</p><p>通常用于函数一等公民的编程语言。</p><h2 id="作用域与词法环境" tabindex="-1">作用域与词法环境 <a class="header-anchor" href="#作用域与词法环境" aria-label="Permalink to &quot;作用域与词法环境&quot;">​</a></h2><p>变量有 3 种作用域，只在所处的作用域中可见：</p><ul><li>全局作用域</li><li>函数作用域</li><li>块作用域</li></ul><p>每个作用域有一个称为<strong>词法环境 (Lexical Environment)</strong> 的隐藏对象。</p><p>词法环境有 2 部分：</p><ul><li>环境记录 (Environment Record)：作用域内所有局部变量</li><li>对外部词法环境的引用 (全局词法环境无外部引用)</li></ul><p>对于<strong>变量</strong>来说，词法环境预先读取所有声明的变量，设为未初始化 (Uninitialized) 状态，在遇到声明之前不能引用，就像该变量不存在一样。遇到声明语句后，变量可以被读取和修改。</p><p><img src="'+l+'" alt=""></p><p>对于<strong>函数</strong>来说，词法环境会预先<strong>读取并初始化</strong>所有声明的函数，允许调用下方声明的函数。</p><p><img src="'+t+'" alt=""></p><p>访问变量时，首先搜索当前作用域的词法环境，其次是外部以及更外部，直到全局。</p><p>如果都没找到，严格模式下报错，非严格模式下会声明一个全局变量。</p><h2 id="闭包-1" tabindex="-1">闭包 <a class="header-anchor" href="#闭包-1" aria-label="Permalink to &quot;闭包&quot;">​</a></h2><p>函数作用域也有自己的词法环境，使用 <code>[[Environment]]</code> 隐藏属性存储对外部环境的引用，创建函数时会自动设置这个属性。</p><p>不管这个函数被传递到什么地方调用，调用时的外部词法环境永远是<strong>声明时</strong>的外部环境，与调用时的外部环境无关，保证了函数的可用性。</p><p><img src="'+p+`" alt=""></p><h2 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h2><p>任何需要访问函数外变量的场景，核心是创建私有变量、延长变量的生命周期。</p><ol><li>各种回调函数 <ul><li>setTimeout</li><li>addEventListener</li></ul></li><li>返回函数的函数，返回的函数需要访问函数内声明的变量 <ul><li>防抖、节流</li><li>柯里化</li></ul></li><li>模拟私有属性和方法：IIFE 返回公有方法，需要访问 IIFE 函数内的私有属性和方法</li><li>解决 var 没有块作用域的问题 <ul><li>外面包一层 IIFE 传入参数来固定 var 变量的值</li></ul></li></ol><h2 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h2><p>函数执行结束后，如果没有其他环境引用这个函数环境，该环境会从内存中删除（垃圾回收）。</p><p>对于返回函数的函数，由于返回的函数引用了外部函数的词法环境，就不会发生垃圾回收，直到返回的函数不再使用，才会回收外部函数。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// g 函数存在时，f 不会被回收</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// g 和 f 都可以回收了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>目前主流的 V8 引擎会对这种情况做一些优化，如果返回的函数<strong>没有引用外部环境的任何变量</strong>，则会将外部函数从外部环境链上删除，并允许回收外部函数。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Surprise!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;the closest value&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在 Console 中输入 value 会显示 &quot;Surprise!&quot;，意味着 f 被回收了</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    debugger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div>`,28),k=[h];function r(d,o,E,g,c,u){return a(),i("div",null,k)}const _=s(e,[["render",r]]);export{F as __pageData,_ as default};
