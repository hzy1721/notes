import{_ as s}from"./chunks/class-extends.dcf01d74.js";import{_ as a,c as l,o as n,d as o}from"./app.6117d686.js";const u=JSON.parse('{"title":"class","description":"","frontmatter":{},"headers":[{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":2,"title":"与构造函数的区别","slug":"与构造函数的区别","link":"#与构造函数的区别","children":[]},{"level":2,"title":"箭头函数属性","slug":"箭头函数属性","link":"#箭头函数属性","children":[]},{"level":2,"title":"继承","slug":"继承","link":"#继承","children":[]}],"relativePath":"fe/basic/js/class.md","lastUpdated":1682732841000}'),e={name:"fe/basic/js/class.md"},p=o(`<h1 id="class" tabindex="-1">class <a class="header-anchor" href="#class" aria-hidden="true">#</a></h1><p>ES6 引入的创建自定义类型的方式。</p><ul><li>可以代替原来的构造函数</li><li>更符合 OOP 的书写习惯</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">MyClass</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SuperClass</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 属性</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">prop1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> value1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 构造方法</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 访问器属性</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop2</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop2</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">newVal</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 实例方法</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">method1</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 静态属性</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">staticProp</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 静态方法</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">staticMethod</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> myInstance </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">MyClass</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-hidden="true">#</a></h2><ul><li>创建一个名为 <code>MyClass</code> 的构造函数，参数和函数体来自 <code>constructor</code></li><li>在函数体内把属性设置到 <code>this</code> 上，比如 <code>prop1</code></li><li>把访问器属性和实例方法设置在原型对象 <code>MyClass.prototype</code> 上，比如 <code>prop2</code>、<code>method1</code></li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">typeof</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{};</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// function</span></span>
<span class="line"></span></code></pre></div><h2 id="与构造函数的区别" tabindex="-1">与构造函数的区别 <a class="header-anchor" href="#与构造函数的区别" aria-hidden="true">#</a></h2><ul><li>内部属性 <code>[[IsClassConstructor]]</code> 的值为 <code>true</code><ul><li>JS 会在很多地方用到这个属性，来区分 <code>class</code> 和构造函数 <ul><li>必须使用 <code>new</code> 调用，直接调用会报错</li><li><code>toString()</code> 的输出以 <code>class</code> 开头，而不是 <code>function</code></li></ul></li></ul></li><li>位于原型上的方法不可枚举 <ul><li><code>enumerable: false</code></li></ul></li><li>总是处于严格模式</li></ul><h2 id="箭头函数属性" tabindex="-1">箭头函数属性 <a class="header-anchor" href="#箭头函数属性" aria-hidden="true">#</a></h2><p>由于箭头函数的 <code>this</code> 会绑定为外层的 <code>this</code>，使用箭头函数属性代替函数声明可以将函数的 <code>this</code> 绑定为创建的对象本身，无论函数被传递到什么地方调用。</p><p>箭头函数属性会作为自有属性在每个对象上都有一份拷贝。</p><h2 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-hidden="true">#</a></h2><p>使用 <code>extends</code> 声明继承，只支持单继承。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Rabbit</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Animal</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span></code></pre></div><p>原理：</p><ul><li>把 <code>Rabbit.prototype.[[Prototype]]</code> 设置为 <code>Animal.prototype</code></li><li>把 <code>Rabbit.[[Prototype]]</code> 设置为 <code>Animal</code></li></ul><img src="`+s+`" width="70%"><ul><li><strong>必须</strong>在子类 constructor 中使用 <code>super()</code> 调用父类 constructor <ul><li>在 <code>this</code> 的访问之前</li><li>为了实现父类实例属性的继承 (非原型属性)</li><li>使用 <code>new</code> 执行子类 constructor 时，不会创建空对象并赋值给 <code>this</code>，而是期望父类 constructor 完成这项工作</li></ul></li><li>可以在子类方法中使用 <code>super.method()</code> 调用父类方法</li><li><code>super</code> 使用内部属性 <code>[[HomeObject]]</code> 实现，值为函数声明时所在的对象</li><li>箭头函数没有自己的 <code>super</code>，与声明时外部环境的 <code>super</code> 相同</li></ul><p>默认生成的 constructor：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Rabbit</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Animal</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(...</span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">super</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">args</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div>`,21),c=[p];function t(r,i,y,d,C,D){return n(),l("div",null,c)}const h=a(e,[["render",t]]);export{u as __pageData,h as default};
