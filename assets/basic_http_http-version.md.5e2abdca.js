import{_ as i,c as l,o as e,U as o}from"./chunks/framework.e548c890.js";const P=JSON.parse('{"title":"HTTP 版本","description":"","frontmatter":{},"headers":[],"relativePath":"basic/http/http-version.md","filePath":"basic/http/http-version.md","lastUpdated":1691809911000}'),t={name:"basic/http/http-version.md"},c=o('<h1 id="http-版本" tabindex="-1">HTTP 版本 <a class="header-anchor" href="#http-版本" aria-label="Permalink to &quot;HTTP 版本&quot;">​</a></h1><h2 id="http-0-9" tabindex="-1">HTTP/0.9 <a class="header-anchor" href="#http-0-9" aria-label="Permalink to &quot;HTTP/0.9&quot;">​</a></h2><p>1991 年发布。</p><ul><li>只支持 <code>GET</code> 方法</li><li>只支持 <code>HTML</code> 类型</li><li>请求完成后关闭 TCP 连接</li></ul><h2 id="http-1-0" tabindex="-1">HTTP/1.0 <a class="header-anchor" href="#http-1-0" aria-label="Permalink to &quot;HTTP/1.0&quot;">​</a></h2><p>1996 年发布。</p><ul><li>新增 <code>POST</code>、<code>HEAD</code> 方法</li><li>新增 HTTP Header，用于描述元数据，必须是 ASCII 编码</li><li>新增状态码 (Status Code)</li><li>支持图片、视频、二进制文件等多种类型，使用 <code>Content-Type</code> 说明数据格式 <ul><li>总称为 <strong>MIME type</strong>，包含一级类型和二级类型</li><li><code>text/plain</code></li><li><code>text/html</code></li><li><code>text/css</code></li><li><code>image/jpeg</code></li><li><code>image/png</code></li><li><code>image/svg+xml</code></li><li><code>audio/mp4</code></li><li><code>video/mp4</code></li><li><code>application/javascript</code></li><li><code>application/pdf</code></li><li><code>application/zip</code></li><li><code>application/atom+xml</code></li><li>也可以自定义类型</li><li>末尾可以使用分号 <code>;</code> 添加参数，比如 <code>text/html; charset=utf-8</code></li></ul></li><li>客户端请求时使用 <code>Accept</code> 声明接受的 MIME 类型</li><li>支持多字符集</li><li>支持 multi-part type</li><li>支持 Authorization</li><li>支持缓存 (启发式缓存)</li><li>支持数据压缩，使用 <code>Content-Encoding</code> 说明压缩方法</li><li>客户端请求时使用 <code>Accept-Encoding</code> 声明支持的压缩方法</li><li>缺点：一个 TCP 连接只发送一个请求，性能比较差</li><li>部分浏览器请求时使用<strong>非标准</strong>的 <code>Connection: keep-alive</code>，要求服务端不要关闭 TCP 连接，如果服务端也回应 <code>Connection: keep-alive</code>，就建立了一个可复用的 TCP 连接</li></ul><h2 id="http-1-1" tabindex="-1">HTTP/1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP/1.1&quot;">​</a></h2><p>1997 年发布。</p><ul><li>新增 <code>PUT</code>、<code>PATCH</code>、<code>OPTIONS</code>、<code>DELETE</code> 方法</li><li>请求头新增 <code>Host</code>，指定服务端域名，一个 IP 可以部署多个域名</li><li>引入<strong>持久连接</strong>：TCP 连接默认不关闭，可以被多个请求复用 <ul><li>客户端和服务端发现对方有一段时间没有活动，可以主动关闭连接</li><li>客户端最好发送最后一个请求时带上 <code>Connection: close</code>，告知服务端关闭连接</li><li>同一个域名，大多数浏览器允许同时建立 6 个持久连接</li></ul></li><li>引入<strong>管道机制 (pipelining)</strong>：允许在一个 TCP 连接里同时发送多个请求 <ul><li>一个 TCP 连接可以发送多个回应，为了区分不同的响应报文，使用 <code>Content-Length</code> 指定数据长度，以字节为单位</li><li>对于耗时操作，最好实时发送生成的数据，而不是全部生成再统一发送。使用 <code>Transfer-Encoding: chunked</code> 指定分块传输编码，每个数据块前有一个十六进制数，表示当前数据块的长度，最后是一个长度为 0 的块</li></ul></li><li>缓存</li><li>内容协商</li><li>缺点：服务器按顺序处理请求，如果处理前面的请求耗时过长，就会造成后面的请求排队，称为<strong>队头阻塞</strong> (head-of-line blocking)。</li></ul><h2 id="http-2" tabindex="-1">HTTP/2 <a class="header-anchor" href="#http-2" aria-label="Permalink to &quot;HTTP/2&quot;">​</a></h2><p>2015 年发布，基于 Google 2009 年公开的 SPDY 协议 (用于解决 HTTP/1.1 效率不高的问题)。</p><ul><li><strong>多工/全双工 (multiplexing)</strong><ul><li>使用一个 TCP 连接，客户端和服务端都可以同时发送多个请求和响应，响应顺序不必对应请求顺序，避免了队头阻塞</li></ul></li><li><strong>二进制协议</strong><ul><li>每个报文的所有帧称为一个数据流 (stream)，有一个唯一编号，附加在每个数据包中 <ul><li>客户端发出的数据流 ID 为奇数，服务端发出的数据流 ID 为偶数</li><li>取消数据流：发送 <code>RST_STREAM</code> 帧</li><li>客户端可以指定数据流的<strong>优先级</strong>，优先级高服务端更早回应</li></ul></li><li>header 和 body 全部采用二进制编码，统称为帧 (frame)，比如头信息帧、数据帧</li><li>可以定义额外的帧，用于高级应用，解析数据相比文本更方便</li></ul></li><li><strong>头信息压缩 (header compression)</strong><ul><li>由于 HTTP 无状态，每次请求需要带上很多重复的 header，浪费带宽、影响速度</li><li>header 使用 gzip 或 compress 压缩后再发送</li><li>客户端和服务端维护一张头信息表，所有字段存入该表并生成索引号，后续只发送索引号</li></ul></li><li><strong>服务器推送 (server push)</strong><ul><li>允许服务端未收到请求就向客户端发送资源，比如主动推送 HTML 需要的静态资源</li></ul></li></ul><h2 id="http-3" tabindex="-1">HTTP/3 <a class="header-anchor" href="#http-3" aria-label="Permalink to &quot;HTTP/3&quot;">​</a></h2><p>UDP + QUIC</p>',15),a=[c];function d(n,r,s,p,h,T){return e(),l("div",null,a)}const g=i(t,[["render",d]]);export{P as __pageData,g as default};
