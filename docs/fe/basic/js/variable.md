# 变量声明

有 6 种声明变量的方法：

- `var`
- `function`
- `let`
- `const`
- `import`
- `class`

## var

- ES5 声明变量的方法，不支持常量
- 只有**函数作用域**和**全局作用域**，没有块作用域
- 变量的声明和赋值会分开，声明会**提升**到作用域顶部
- 不声明直接赋值的变量会声明为**全局变量**
- 缺点：
  - 块作用域内层变量覆盖外层变量
  - 循环变量泄漏为外层变量
- 通常使用 IIFE 实现块作用域
  - Immediately Invoked Function Expression

## let

- ES6 声明变量的方法，具有块作用域
- for 循环中的循环变量与循环体内部的变量有各自单独的作用域
- 只能在声明后使用
  - 块作用域内一旦有 let 和 const 声明，声明前的部分都不能访问对应的变量，即使存在同名的全局变量
  - 作用域开头与声明之间的区域称为 Temporal Dead Zone (TDZ)，为了确保不在变量声明之前使用变量
- 不允许在同一作用域内重复声明
- 块作用域必须加花括号，没有花括号就不存在块作用域，编写 ES6 代码应避免省略花括号

## const

- ES6 声明常量的方法，必须立即初始化
- `let` 的大部分规则也适用于 `const`
- 保证常量所在内存地址的数据不被修改
  - 对于原始类型表示值不会改变
  - 对于对象类型表示指向的对象不会改变，但对象内部的属性是可以修改的
  - 如果想让对象的属性也不可修改，可以使用 `Object.freeze`
    - 冻结后的对象不能新增和删除属性，已有的属性也不能修改
    - 如果对象的属性也有可能是对象，为了完全冻结，可以递归应用 `Object.freeze`

## 顶层变量

- 顶层变量在浏览器中是 `window`，在 Node 中是 `global`
- ES5 中顶层变量的属性与全局变量等价
- ES6 中
  - `var` 和 `function` 声明的全局变量与顶层变量的属性等价
  - `let`、`const`、`class` 声明的全局变量不属于顶层变量的属性
- 由于变量名不同等因素，很难找到一种方法在所有情况下都取到顶层对象
  - ES2020 引入了 `globalThis`，在所有环境下都能取到，指向全局环境下的 `this`
